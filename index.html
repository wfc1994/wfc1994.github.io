<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">








  <meta name="google-site-verification" content="z3k0SzBPBi4QC4z1EogQtF8HeqqS4Ghg1igDeqMR3uQ">



  <meta name="msvalidate.01" content="true">













<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.1.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.2">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.2" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="只想当扫地机器人的老王">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="只想当扫地机器人的老王">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="只想当扫地机器人的老王">





  
  
  <link rel="canonical" href="http://yoursite.com/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>只想当扫地机器人的老王</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
	<a href="https://github.com/wfc1994" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#70B7FD; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">只想当扫地机器人的老王</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-schedule">

    
    
    
      
    

    

    <a href="/schedule/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>日程表</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/10/看书笔记/深入理解Java虚拟机/11、多线程与JVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wfc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="只想当扫地机器人的老王">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/10/看书笔记/深入理解Java虚拟机/11、多线程与JVM/" class="post-title-link" itemprop="url">11、多线程与JVM</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-10 07:57:02" itemprop="dateCreated datePublished" datetime="2019-07-10T07:57:02+08:00">2019-07-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-09 17:13:33" itemprop="dateModified" datetime="2019-07-09T17:13:33+08:00">2019-07-09</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/看书笔记/" itemprop="url" rel="index"><span itemprop="name">看书笔记</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/看书笔记/深入理解Java虚拟机/" itemprop="url" rel="index"><span itemprop="name">深入理解Java虚拟机</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、Java内存模型与线程"><a href="#一、Java内存模型与线程" class="headerlink" title="一、Java内存模型与线程"></a>一、Java内存模型与线程</h2><h3 id="1、硬件的效率与一致性"><a href="#1、硬件的效率与一致性" class="headerlink" title="1、硬件的效率与一致性"></a>1、硬件的效率与一致性</h3><p>由于计算机的存储设备与处理器的运算速度有好几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。</p>
<p>基于高速缓存的存储交互很好的解决了处理器与内存的速度矛盾，但是也为计算机系统带来了更高的复杂度，因为它引入了一个新的问题：缓存一致性。在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存，当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致。</p>
<p>为了解决缓存一致性问题，需要各个处理器访问缓存时都遵守一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI、MOSI、Synapse、Firefly及Dragon Protocol等。而Java虚拟机也有自己的内存模型。</p>
<p>除了增加了高速缓存之外，为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行优化，处理器会在计算之后将乱序执行结果进行重组，保证结果与顺序执行的结果是一致的，但不保证程序中的各个语句计算的先后顺序与输入代码中的顺序一致，因此，如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后执行顺序来保证。</p>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8EJVM1.png" alt></p>
<p>与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有类似的指令重排序优化。</p>
<h3 id="2、java内存模型"><a href="#2、java内存模型" class="headerlink" title="2、java内存模型"></a>2、java内存模型</h3><p>Java虚拟机规范中试图定义一种Java内存模型来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台上都能达到一致的内存访问效果。</p>
<h4 id="a-主内存和工作内存"><a href="#a-主内存和工作内存" class="headerlink" title="a.主内存和工作内存"></a>a.主内存和工作内存</h4><ul>
<li>Java内存模型主要目标：定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。</li>
<li>此处的变量（Variable）与Java编程中的变量略有区别，它包括实例变量/静态字段和构成数组对象的元素，不包括局部变量和方法参数（线程私有）</li>
<li>为获得较好的执行效能，Java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交换，也没有限制即时编译器调整代码执行顺序这类权利。</li>
</ul>
<p>Java内存模型规定所有变量都存储在主存（Main Memory）中（虚拟机内存的一部分）。每条线程还有自己的工作内存（Working Memory），线程的工作内存保存了被线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取/赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主存来完成。</p>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8EJVM2.png" alt></p>
<p><strong>注意：这里所讲的主内存、工作内存与前面讲解Java内存区域中的Java堆、栈、方法区等不适同一个层次划分，两者无任何关系</strong>。</p>
<p>如果两者一定要勉强对应起来，那从变量/主内存/工作内存的定义来看，主内存主要对应于Java堆中对象的实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。从更低的层次来说，主存就是硬件的内存，而为获取更好的运算速度，虚拟机及硬件系统可能会让工作内存优先存储于寄存器和高速缓存。</p>
<h4 id="b-内存间交互操作"><a href="#b-内存间交互操作" class="headerlink" title="b.内存间交互操作"></a>b.内存间交互操作</h4><ol>
<li>lock，锁定：作用于主内存的变量，把一个变量标识为一条线程独占的状态；</li>
<li>unlock，解锁：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定；</li>
<li>read，读取：作用于主内存的变量，把一个变量的值从主内存传输到线程的工作内存中，方便随后的load动作使用；</li>
<li>load，载入：作用于工作内存的变量，把read操作从主内存中得到的变量值放到工作内存的变量副本中；</li>
<li>use，使用：作用域工作内存的变量，把工作内存中的一个变量的值传给执行引擎，每当虚拟机遇到一个需要使用到变量的值得字节码指令时会执行这个操作；</li>
<li>assign，赋值：作用于工作内存的变量，把一个从执行引擎收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作；</li>
<li>store，存储：作用于工作内存的变量，把工作内存中一个变量的值传送给主内存中，方便随后的write操作使用；</li>
<li>write，写入：作用于主内存的变量，把store操作从工作内存中得到的变量的值放入主内存变量中。</li>
</ol>
<p>注意： Java内存模型只要求上述两个操作必须按照顺序执行，而没有保证是连续执行。也就是说，read 和 load 之间、store 和 write 之间是可插入其他指令的。如对内存中的变量a、b 进行访问时，一种可能出现的顺序是 ：read a、read b、load b、load a 。</p>
<p>除此之外，Java内存模型还规定在执行上述8种操作需满足的规则：</p>
<ol>
<li>不允许read和load、store和write操作单一出现，即不允许一个变量从主内存读取了但工作内存不接收，或者工作内存发起回写了但主内存不接收；</li>
<li>不允许一个线程丢弃最近的assign操作，即变量在工作内存中改变了之后必须要把变化同步到主内存中；</li>
<li>不允许一个线程无原因的把数组从线程的工作内存同步回主内存（性能考量）；</li>
<li>一个新变量只能在主内存中诞生，不允许在工作内存中直接使用一个未初始化的变量；</li>
<li>一个变量同一时刻只允许一条线程对其lock操作，但lock操作可以被同一条线程执行多次，多次执行lock后需要执行相同次数的unlock操作，变量才会解锁；</li>
<li>如果对一个变量进行lock操作，会清空工作内存中该变量的值，在执行引擎使用这个变量前需要重新执行load和assign操作；</li>
<li>如果一个变量事先没有被lock锁定，那不允许unlock操作出现，也不允许unlock其他一个线程锁定的线程；</li>
<li>对一个变量执行unlock操作之前，必须先把该变量同步回主内存中。</li>
</ol>
<h4 id="c-对于volatile型变量的特殊规则"><a href="#c-对于volatile型变量的特殊规则" class="headerlink" title="c.对于volatile型变量的特殊规则"></a>c.对于volatile型变量的特殊规则</h4><p>可见性</p>
<p>当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量做不到这一点，其在线程间传递需要通过主内存来完成</p>
<p>禁止指令重排序</p>
<ul>
<li>普通变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致.</li>
<li>从硬件架构上讲，指令重排序是指cpu采用了允许将多条指令不按程序规定的顺序分开发送给相应的电路单元处理。但并不是指令任意重排，cpu需要能正确处理指令依赖情况以保障程序能得到正确的执行结果。例如指令1把地址A中的值加10，指令2把地址A中的值乘以2，指令3把地址B中的值减去3，这时指令1和指令2是有依赖的，它们之间的顺序是不能重排的，但是指令3可以重排到指令1和2之前或者中间，只要保证cpu执行后面依赖A、B值的操作时能获得正确的A、B值即可。所以在本内CPU中，重排序看起来依然是有序的。因此，lock指令把修改同步到内存时，意味着所有之前的操作都已经执行完成，这样便形成了“指令重排序无法越过内存屏障”的效果。重排序会破坏了多线程程序的语义，因此才需要诸如volatile这样的技术来禁止重排序！</li>
</ul>
<p>volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，仍然需要通过加锁保证原子性：</p>
<p>（1）运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值；</p>
<p>（2）变量不需要与其他的状态变量共同参与不变约束。</p>
<p>volatile指令操作，它的作用相当于一个内存屏障（Memory Barrier），指重排序时不能把后面的指令重排序到内存屏障之前的位置。当两个或以上的CPU访问同一块内存时，需要内存屏障来保证一致性。</p>
<h4 id="d-对于LONG和Double类型变量的特殊规则"><a href="#d-对于LONG和Double类型变量的特殊规则" class="headerlink" title="d.对于LONG和Double类型变量的特殊规则"></a>d.对于LONG和Double类型变量的特殊规则</h4><p>Java内存模型要求lock、unlock、read、load、use、assign、store、write这八个操作都具有原子性，但是对于64位的数据类型（long和double），在模型中特别定义了一条相对宽松的规定：允许虚拟机将没有被volatile修饰的64位数据类型的读写操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这四个操作的原子性，这点就是所谓的long和double的非原子协定。</p>
<p>上面也就是说没有被volatile修饰的64位数据类型的变量如果被多个线程共享，并且同时对其进行读取和修改操作，那么某些线程可能会读取到一个既非原值，也非其他线程修改的“半个变量”的数值。</p>
<p>不过读取到“半个变量”的情况非常罕见（在目前的商用Java虚拟机中不会出现），因为Java内存模型虽然允许虚拟机不把long和double变量的读写实现成原子操作，但允许虚拟机选择把这些操作实现为具有原子性的操作，而且还“强烈建议”虚拟机这样实现。</p>
<p>在实际的开发中，目前各种平台下的商用虚拟机几乎都选择把64位数据的读写操作作为原子操作来对待，因此我们在编写代码时一般不需要把用到的long和double变量专门声明为volatile。</p>
<h4 id="e-原子性、可见性与有序性"><a href="#e-原子性、可见性与有序性" class="headerlink" title="e.原子性、可见性与有序性"></a>e.原子性、可见性与有序性</h4><p>Java内存模型围绕着在并发过程中如何处理原子性、可见性、有序性这三个特征来建立的。</p>
<h5 id="1、原子性："><a href="#1、原子性：" class="headerlink" title="1、原子性："></a>1、原子性：</h5><ul>
<li><p>定义：由于Java内存模型来直接保证的原子性变量操作包括 read，load，assign，use，store和write，我们大致认为基本数据类型的访问读写数据是具备原子性的。</p>
</li>
<li><p>更大范围的原子性保证：如果应用场景需要一个更大范围的原子性保证，Java内存模型还提供了lock 和 unlock 操作来满足这些需求，尽管虚拟机没有把lock 和 unlock 操作直接开放给用户使用，但是却提供了更高层次的字节码指令 monitorenter 和 monitorexit 来隐式地使用这两个操作。</p>
</li>
<li><p>synchronized关键字：monitorenter 和 monitorexit 这两个字节码指令反映到java代码中就是同步块——synchronized关键字，因此在synchronized块之间的操作也具备原子性。</p>
</li>
</ul>
<h5 id="2、可见性："><a href="#2、可见性：" class="headerlink" title="2、可见性："></a>2、可见性：</h5><ul>
<li><p>可见性：指当一个线程修改了共享变量的值，其他能够立即得知这个修改。</p>
</li>
<li><p>定义：Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是volatile变量都是如此</p>
</li>
<li><p>普通变量与 volatile变量的区别：volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新，所以volatile保证了多线程操作时变量的可见性，普通变量则不能保证这一点。</p>
</li>
<li><p>synchronized 和 final关键字：除了volatile关键字外，Java还有两个关键字实现可见性： synchronized 和 final。</p>
</li>
<li><p>synchronized同步块的可见性： 是由对一个变量执行unlock 操作前，必须先把此变量同步回主内存中；</p>
</li>
<li><p>final关键字的可见性：被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把this 的引用传递出去（this引用传递很危险，其他线程很有可能通过此引用访问到“初始化了一半”的对象），那在其他线程中就能看见final 字段的值。</p>
</li>
</ul>
<h5 id="3、有序性："><a href="#3、有序性：" class="headerlink" title="3、有序性："></a>3、有序性：</h5><ul>
<li><p>如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指 “线程内表现为串行”的语义，后半句是指 “指令重排序”现象和“工作内存与主内存同步延迟”现象。</p>
</li>
<li><p>volatile和 synchronized关键字保证了线程间操作的有序性：</p>
</li>
</ul>
<ol>
<li>volatile关键字本身就包含了禁止指令重排序的语义。</li>
<li>synchronized则是由 一个变量在同一时刻只允许一条线程对其进行lock 操作这条规则获得的，这条规则决定了持有同一个锁的两个同步块只能串行地进入。</li>
</ol>
<h4 id="f-先行发生原则"><a href="#f-先行发生原则" class="headerlink" title="f.先行发生原则"></a>f.先行发生原则</h4><p>先行发生原则定义：先行发生是Java内存模型中定义的两项操作之间的偏序关系，如果说操作A 先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到， 影响包括 修改了内存中共享变量的值，发送了消息，调用了方法等。</p>
<ul>
<li>程序次序规则：同一个线程中，按照程序代码顺序。</li>
<li>管程锁定规则：一个unlock操作先行发生与后面对同一个锁的lock操作。</li>
<li>volatile变量规则：volatile变量写操作先行发生于后面这个变量的读操作。</li>
<li>线程启动规则：Thread对象start方法先行发生于此线程的每个操作。</li>
<li>线程终止规则：Thread对象所有操作先行发生于对此对象的终止检测，通过Thread.join()方法结束，Thread.isAlive()返回值检测。</li>
<li>线程中断规则：对线程interrupt()方法调用先行发生于被中断的代码检测到中断事件的发生，通过Thread.interrupt()方法检测。</li>
<li>对象终结规则：一个对象初始化完成先行发生于它的finalize()方法的开始。</li>
<li>传递性：如果A先行发生于B，B先行发生于C，那么A先行发生于C。</li>
</ul>
<h3 id="3、Java与线程"><a href="#3、Java与线程" class="headerlink" title="3、Java与线程"></a>3、Java与线程</h3><p>线程其实是比进程更轻量级的调度执行单位。线程的引入，可以把一个检查的资源分配和执行调度分开，各个线程既可以共享资源（内存地址、文件I/O等），又可以独立调度（线程是CPU调度的基本单位）。</p>
<h4 id="a-线程的实现"><a href="#a-线程的实现" class="headerlink" title="a.线程的实现"></a>a.线程的实现</h4><p>实现线程的3种方式分别是：使用内核线程实现；使用用户线程实现；使用用户线程加轻量级进程混合实现。</p>
<p>内核线程：</p>
<p>定义：直接由操作系统内核支持的线程。</p>
<p>原理：</p>
<ul>
<li>内核线程（Kernel-Level Thread）： 就是直接由操作系统内核（下称内核）支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。</li>
<li>多线程内核（Multi-Threads Kernel）：每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多个事情，支持多线程的内核就叫多线程内核。</li>
<li>轻量级进程（Light Weight Process）：程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程：轻量级进程就是我们通常意义上讲的线程。</li>
<li>轻量级进程与内核线程之间关系：由于每个轻量级线程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。这种轻量级进程与内核线程间1:1 的关系称为一对一的线程模型，</li>
</ul>
<p>优点：每个轻量级进程都由一个内核线程支持，因此每个都成为一个独立的调度单元，即使有一个轻量级进程在系统调用中阻塞，也不会影响整个进程继续工作。</p>
<p>缺点：由于基于内核线程实现，所以各种线程操作（创建、析构及同步）都需要进行系统调用，代价相对较高，需要在用户态（User Mode）和内核态（Kernel Mode）中来回切换；另外，一个系统支持轻量级进程的数量是有限的。</p>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8EJVM3.png" alt></p>
<p>用户线程：</p>
<ul>
<li>定义：广义上认为一个线程不是内核线程就是用户线程；狭义上认为用户线程指的是完全建立在用户空间的线程库上，而系统内核不能感知线程存在的实现。</li>
<li>优点：由于用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助，甚至可以不需要切换到内核态，所以操作非常快速且低消耗的，且可以支持规模更大的线程数量。</li>
<li>缺点：由于没有系统内核的支援，所有的线程操作都需要用户程序自己处理，线程的创建、切换和调度都是需要考虑的问题，实现较复杂。</li>
<li>一对多的线程模型进程：进程与用户线程之间1：N的关系</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8EJVM4.png" alt></p>
<p>用户线程和轻量级进程混合：</p>
<ul>
<li>定义：既存在用户线程，也存在轻量级进程。</li>
<li>优点：用户线程完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发；操作系统提供支持的轻量级进程作为用户线程和内核线程之间的桥梁，可以使用内核提供的线程调度功能及处理器映射，且用户线程的系统调用要通过轻量级线程来完成，大大降低了整个进程被完全阻塞的风险。</li>
<li>多对多的线程模型：用户线程与轻量级进程的数量比不定，即用户线程与轻量级进程之间N：M的关系</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8EJVM5.png" alt></p>
<p>Java线程：</p>
<p>JDK1.2前使用基于称为“绿色线程”的用户线程实现的，1.2以后替换为基于操作系统原生线程模型实现。 Sun JDK来说，它的Windows版本与Linux版本都是使用一对一的线程模型实现的，一条Java线程就映射到一条轻量级进程中，因为Windows和Linux系统提供的线程模型就是一对一的</p>
<h4 id="b-Java线程调度"><a href="#b-Java线程调度" class="headerlink" title="b.Java线程调度"></a>b.Java线程调度</h4><p>线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种：</p>
<p>协同式线程调度和抢占式线程调度。</p>
<p>协同式线程调度：线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上。</p>
<ul>
<li><p>优点：实现简单，无线程同步问题（因为都是要把自己的事情干完才会进行线程切换）；</p>
</li>
<li><p>缺点：线程执行时间不可控制，甚至如果一个线程编写有问题，一直不告知系统进行线程切换，那么程序会一直阻塞在那里。</p>
</li>
</ul>
<p>抢占式线程调度：每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定（在Java中，Thread.yield()可以让出执行时间，但是要获取执行时间的话，线程本身是没有什么办法的）。在这种实现线程调度的方式下，线程的执行时间是系统可控的，也不会有一个线程导致整个进程阻塞的问题，Java使用的就是抢占式调度。</p>
<h4 id="c-Java线程优先级"><a href="#c-Java线程优先级" class="headerlink" title="c.Java线程优先级"></a>c.Java线程优先级</h4><p>虽然Java 线程调度是系统自动完成的，但我们还是可以建议系统给某些线程多分配一点执行时间，另外一些线程则可以少分配一点——这项操作可以通过设置线程优先级来完成。Java语言一共设置了10个级别的优先级，在两个线程同时处于Ready状态，优先级越高的线程越容易被系统选择执行。</p>
<p>不过线程优先级并不是太靠谱，原因是因为Java的线程是通过映射到系统的原生线程上来实现的，所以线程调度最终还是取决于 操作系统，虽然现在很多os 都提供了线程优先级，但不见得和 能与 java线程的优先级一一对应。如 Solaris中有 2^32 种优先级，而windows只有7种 。</p>
<h4 id="d-状态切换"><a href="#d-状态切换" class="headerlink" title="d.状态切换"></a>d.状态切换</h4><ol>
<li><p>新建（New）：创建后尚未启动的线程处于这个状态。</p>
</li>
<li><p>运行（Runnable）： Runable包括了os 线程状态中的 Running 和 Ready，也就是处于 此状态的线程有可能正在执行，也有可能正在等待着CPU 为它分配执行时间。</p>
</li>
<li><p>无限期等待（Waiting）：处于这种状态的线程不会被分配CPU执行时间，它们要等待被其他线程显式的唤醒。以下方法会让线程陷入无限期的等待状态：</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">没有设置Timeout参数的Object.wait()方法；</span><br><span class="line"></span><br><span class="line">没有设置Timeout参数的 Thread.join() 方法；</span><br><span class="line"></span><br><span class="line">LockSupport.park() 方法；</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>限期等待（Timed Waiting）：处于这种状态的线程也不会被分配CPU 执行时间，不过无需等待被其他线程显式唤醒，在一定时间之后，它们会由系统自动唤醒。以下方法会让线程进入限期等待状态：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thread.sleep() 方法；</span><br><span class="line">    </span><br><span class="line">设置了Timeout参数的Object.wait()方法；</span><br><span class="line">    </span><br><span class="line">设置了Timeout参数的 Thread.join() 方法；</span><br><span class="line">    </span><br><span class="line">LockSupport.parkNanos() 方法；</span><br><span class="line">    </span><br><span class="line">LockSupport.parkUntil() 方法；</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>阻塞（Blocked）：线程被阻塞了， “阻塞状态”与“等待状态”的区别是：“阻塞状态”在等待着获取到一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。</p>
</li>
<li><p>结束（Terminated）：已经终止线程的线程状态，线程已经结束执行。</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8EJVM6.png" alt></p>
<h2 id="二、线程安全与锁优化"><a href="#二、线程安全与锁优化" class="headerlink" title="二、线程安全与锁优化"></a>二、线程安全与锁优化</h2><h3 id="1、线程安全"><a href="#1、线程安全" class="headerlink" title="1、线程安全"></a>1、线程安全</h3><p>代码本身封装了所有必要的正确性保障手段（如互斥同步），令调用者无须关心多线程的问题，更无须自己采取任何措施来保证多线程的正确调用。</p>
<h4 id="a-不可变"><a href="#a-不可变" class="headerlink" title="a 不可变"></a>a 不可变</h4><p>（1）定义:</p>
<ul>
<li>不可变对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要采取任何的线程安全保障措施。</li>
<li>如果共享数据是一个基本数据类型，那么只要在定义时使用 final 关键字修饰它就可以保证它是不可变的。</li>
<li>如果共享的是一个对象，需要保证对象行为不会对其状态产生任何影响。</li>
</ul>
<p>例如 java.lang.String类的对象：它是一个典型的不可变对象，调用它的substring(), replace(), concat() 这些方法都不会影响它原来的值，只会返回一个新构造的字符串对象。</p>
<p>（2）保证对象行为途径</p>
<p>途径有多种，其中最简单的就是把对象中带有状态的变量都声明为final，这样在构造函数之后，它就是不可变的。</p>
<h4 id="b-绝对线程安全"><a href="#b-绝对线程安全" class="headerlink" title="b.绝对线程安全"></a>b.绝对线程安全</h4><p>（1）定义</p>
<p>一个类要达到“不管运行环境如何，调用者都不需要任何额外的同步措施”通常需要付出很大。在Java API中标注自己是线程安全的类，大多数都不是绝对的线程安全。</p>
<p>例如 java.util.Vector 是一个线程安全的容器，因为它的add()方法、get()方法、size()方法这些方法都是被synchronized修饰的，尽管效率低下，但确实是安全的。可以即使如此并不意味着调用它的时候不需要同步手段了.</p>
<p>但是有时候还会抛出异常，抛出异常的原因：因为如果另一个线程恰好在错误的时间里删除了一个元素，导致序号i 已经不再可用的话，再用i 访问数组就会抛出一个 ArrayIndexOutOfBoundsException。</p>
<h4 id="c-相对线程安全"><a href="#c-相对线程安全" class="headerlink" title="c. 相对线程安全"></a>c. 相对线程安全</h4><p>（1）定义</p>
<p>相对线程的安全就是通常意义上所讲的线程安全，它需要保证对这个对象单独操作是线程安全的。开发人员在调用的时候不需要做额外保障措施，但是对于一些特定顺序连续调用，就需要在调用端使用额外的同步手段来保证调用正确性。</p>
<h4 id="d-线程兼容"><a href="#d-线程兼容" class="headerlink" title="d. 线程兼容"></a>d. 线程兼容</h4><p>（1）定义</p>
<p>线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。平常所说的一个类不是线程安全，绝大多数指这种情况。</p>
<p>Java API 大部分类属于线程兼容的，如之前的Vector和 HashTable相对应的集合类ArrayList 和 HashMap等。</p>
<h4 id="e-线程对立"><a href="#e-线程对立" class="headerlink" title="e. 线程对立"></a>e. 线程对立</h4><p>指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。</p>
<p>注意：由于java语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常是有害的，应当尽量避免。</p>
<p>例如Thread类的suspend() 和 resume() 方法，如果有两个线程同时持有一个线程对象，一个尝试去中断线程，另一个尝试去恢复线程，如果并发进行的话，无论调用时是否进行了同步，目标线程都是存在死锁风险的。</p>
<h3 id="2、线程安全的实现方法"><a href="#2、线程安全的实现方法" class="headerlink" title="2、线程安全的实现方法"></a>2、线程安全的实现方法</h3><h4 id="a-互斥同步（Mutual-Exclusion-amp-Synchronization）"><a href="#a-互斥同步（Mutual-Exclusion-amp-Synchronization）" class="headerlink" title="a. 互斥同步（Mutual Exclusion &amp; Synchronization）"></a>a. 互斥同步（Mutual Exclusion &amp; Synchronization）</h4><p>（1）定义</p>
<p>互斥同步是常见的并发正确性保障手段。</p>
<p>同步：是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻被一个线程使用。</p>
<p>互斥：互斥是实现同步的一种手段。临界区，互斥量和信号量都是主要的互斥实现方式。因此，在这4个字里面，互斥是因，同步是果；互斥是方法，同步是目的。</p>
<p>（2）synchronized关键字</p>
<p>最基本的互斥同步手段就是 synchronized关键字，synchronized关键字经过编译之后，会在同步块的前后分别形成 monitorenter 和 monitorexit 这个两个字节码指令，这两个字节码都需要一个 reference类型的参数来指明要锁定和解锁的对象。</p>
<p>如果java程序中的synchronized明确指定了对象参数，那就是这个对象的reference。</p>
<p>如果没有明确指定，那就根据 synchronized修饰的实例方法还是类方法，去取对应的对象实例或Class 对象来作为锁对象。</p>
<p>（3）monitorenter和monitorexit 指令执行</p>
<p>根据虚拟机规范的要求：在执行monitorenter指令时，如果这个对象没有锁定或当前线程已经拥有了那个对象的锁，锁的计数器加1，相应的，在执行 monitorexit 指令时会将锁计数器减1；当计数器为0时，锁就被释放了。其中有两点需要注意：</p>
<p>synchronized同步块对同一条线程来说是可重入的， 不会出现自己把自己锁死的问题。</p>
<p>同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。</p>
<p>（4）重入锁（ReentrantLock）</p>
<p>除了synchronized之外，还可以使用 java.util.concurrent 包中的重入锁来实现同步。</p>
<p>synchronized 和 ReentrantLock 的区别： 一个表现为 API 层面的互斥锁（lock() 和 unlock() 方法配合 try/finally 语句块来完成），另一个表现为 原生语法层面的互斥锁。</p>
<p>（5）ReentrantLock新增的高级功能</p>
<p>主要有3项：等待可中断，可实现公平锁， 以及锁可以绑定多个条件。</p>
<p>等待可中断：指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助；</p>
<p>公平锁：指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；</p>
<p>锁绑定多个条件：指一个 ReentrantLock对象可以同时绑定多个 Condition对象，而在 synchronized中，锁对象的wait() 和 notify() 或 notifyAll() 方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁，而ReentrantLock 则无需这样做，只需要多次调用 newCondition() 方法即可。</p>
<h4 id="b-非阻塞同步"><a href="#b-非阻塞同步" class="headerlink" title="b. 非阻塞同步"></a>b. 非阻塞同步</h4><p>互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，称为阻塞同步。</p>
<p>（1）定义</p>
<p>基于冲突检测的乐观并发策略，通俗的说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了。如果共享数据有争用，产生了冲突，那就再采用其他的补偿措施，这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为 非阻塞同步。</p>
<p>（2）硬件指令集</p>
<p>为什么使用乐观并发策略需要“硬件指令集的发展”才能进行呢？因为我们需要操作和冲突检测这两个步骤具备原子性，靠什么来保证呢？</p>
<p>是硬件，它保证一个从语义上看起来需要多次操作的行为只通过一次处理器指令就能完成，这类指令常用的有：</p>
<ul>
<li>测试并设置（Test-and-Set）</li>
<li>获取并增加（Fetch-and-Increment）</li>
<li>交换（Swap）</li>
<li>比较并交换（Compare-and-Swap，下文简称 CAS）</li>
<li>加载链接/ 条件存储（Load-Linked/Store-Conditional，下文简称 LL/SC）</li>
</ul>
<p>（3）CAS 操作避免阻塞同步</p>
<p>如何使用CAS 操作来避免阻塞同步:原子类。</p>
<p>（4）CAS操作（比较并交换操作）的ABA问题</p>
<p>如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就说它的值没有被其他线程改变过了吗？ 如果在这段期间它的值曾经被改为了B，之后又改回了A，那CAS操作就会误认为它从来没有被改变过，这个漏洞称为 CAS操作的 ABA问题。</p>
<p>（5）解决方法</p>
<p>J.U.C 包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。不过目前来说这个类比较鸡肋， 大部分情况下 ABA问题 不会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。</p>
<h4 id="c-无同步方案"><a href="#c-无同步方案" class="headerlink" title="c. 无同步方案"></a>c. 无同步方案</h4><p>如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性，因此会有一些代码天生就是线程安全的，下面介绍其中的两类。</p>
<p>（1）可重入代码（Reentrant Code）</p>
<p>也叫作纯代码，可以在代码执行的任何时刻中断它，转而去执行另外一段代码，而在控制权返回后，原来的程序不会出现任何错误。</p>
<p>所有的可重入代码都是线程安全的；</p>
<p>如何判断代码是否具备可重入性：如果一个方法，它的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的。</p>
<p>（2）线程本地存储（Thread Local Storage）</p>
<p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能够保证在同一线程中执行？ 如果能保证，我们就可以把共享数据的可见范围限制在同一个线程内，这样，无需同步也可以保证线程间不出现数据争用问题。</p>
<h3 id="3、锁优化"><a href="#3、锁优化" class="headerlink" title="3、锁优化"></a>3、锁优化</h3><h4 id="a-自旋锁与自适应自旋"><a href="#a-自旋锁与自适应自旋" class="headerlink" title="a.自旋锁与自适应自旋"></a>a.自旋锁与自适应自旋</h4><p>（1）定义</p>
<p>若物理机有一个以上的处理器，能让两个或以上的线程同时执行，就可以让后面请求锁的线程“稍等”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。</p>
<p>为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。</p>
<p>（2）自旋等待时间限度</p>
<p>自旋等待不能代替阻塞，它本身虽避免了线程切换的开销，但仍要占用处理器时间。因此时间占用越短，效果越好，反之自旋的线程只会白白消耗处理器资源，带来性能浪费。</p>
<p>自旋等待的时间必须要有一定的限度， 如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了。自旋次数的默认值是10，用户可以用参数 -XX:PreBlockSpin 来更改。</p>
<p>（3）自适应自旋锁</p>
<p>JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定：</p>
<ul>
<li><p>如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100个循环。</p>
</li>
<li><p>如果对于某个锁，自旋很少成功获得过， 那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。</p>
</li>
</ul>
<h4 id="b-锁消除"><a href="#b-锁消除" class="headerlink" title="b.锁消除"></a>b.锁消除</h4><p>（1）定义</p>
<p>锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检查到不可能存在共享数据竞争的锁进行消除。</p>
<p>（2）锁消除的主要判定依据</p>
<p>来源于逃逸分析的数据支持，如果判定在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行。</p>
<p>（3）Java程序中“默认”存在的同步操作</p>
<p>程序员应该很清楚，怎么会明知道不存在数据争用的情况下要求同步呢？需要注意，许多同步措施不是程序员自己加的，而是某些而Java程序自带的。</p>
<h4 id="c-锁粗化"><a href="#c-锁粗化" class="headerlink" title="c.锁粗化"></a>c.锁粗化</h4><p>（1）同步操作数量尽可能少原则</p>
<p>在编写代码时，总是推荐同步块的作用范围尽可能小——-只在共享数据的实际作用域中才进行同步，这是为了同步操作数量尽可能少，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。</p>
<p>（2）问题</p>
<p>大多数情况下，上面原则正确。如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。</p>
<p>（3）解决方法——锁粗化</p>
<p>如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。</p>
<h4 id="d-轻量级锁"><a href="#d-轻量级锁" class="headerlink" title="d.轻量级锁"></a>d.轻量级锁</h4><p>（1）定义和作用</p>
<p>定义：“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言，传统的锁机制就称为“重量级”锁。</p>
<p>目的：轻量级锁并非用来代替重量级锁，本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。</p>
<p>（2）HotSpot虚拟机的对象头</p>
<p>要理解轻量级锁，首先需要了解HotSpot虚拟机的对象头，分为两部分信息：</p>
<p>第一部分：用于存储对象自身的运行时数据，如哈希码，GC分代年龄等；这部分数据的长度在32位和64位的虚拟机中分别为 32bit 和 64bit，官方称它为 Mark Word，它是实现轻量级锁和偏向锁的关键。<br>第二部分：用于存储指向方法区对象类型数据的指针，如果是数组对象的话，还会有一个额外的部分用于存储数组长度。<br>（3）HotSpot 虚拟机对象头Mark Word</p>
<p>对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word 被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会工具对象的状态复用自己的存储空间。</p>
<p>（4）轻量级锁的加锁过程</p>
<p>在代码进入同步块的时候，轻量级锁的加锁过程如下：</p>
<p>1）如果此同步对象没有被锁定（锁标志位为01状态），虚拟机首先将在当前线程的栈帧中建立一个名为 锁记录的空间，用于存储对象目前的Mark Word 的拷贝。</p>
<p>2）然后，虚拟机将使用CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record的指针。</p>
<p>3）如果这个更新工作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位将转变为 00，即表示 此对象处于轻量级锁定状态。</p>
<p>4）如果这个更新失败了，虚拟机首先会检查对象的Mark Word 是否指向当前线程的栈帧，如果只说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明这个锁对象以及被其他线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁，锁标志的状态值变为 10，Mark Word中存储的就是指向重量级（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。</p>
<p>（5）轻量级锁的解锁过程</p>
<p>1）如果对象的Mark Word仍然指向着线程的锁记录，那就用CAS 操作把对象当前的Mark Word 和 线程中复制的 Dispatched Mard Word替换回来。</p>
<p>2）如果替换成功，整个同步过程就完成。</p>
<p>3）如果替换失败，说明有其他线程尝试过获取该锁，那就要在释放锁的同时，唤醒被挂起的线程。</p>
<p>（6）小结</p>
<p>轻量级锁能提升程序同步性能的依据是： 对于绝大部分的锁，在整个同步周期内都是不存在竞争的。</p>
<p>如果没有竞争，轻量级锁使用CAS 操作避免了使用互斥量的开销。</p>
<p>如果存在锁竞争，除了互斥量的开销外，还额外发生了CAS 操作，因此在有竞争的情况下， 轻量级锁会比传统的重量级锁更慢。</p>
<h4 id="e-偏向锁"><a href="#e-偏向锁" class="headerlink" title="e.偏向锁"></a>e.偏向锁</h4><p>（1）定义与目的</p>
<p>目的：消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。</p>
<p>定义： 如果说轻量级锁是在无竞争的情况使用CAS 操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS 操作都不做了。</p>
<p>（2）偏向锁中的“偏”</p>
<p>它的意思是这个锁会偏向于 第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。</p>
<p>（3）偏向锁的原理</p>
<p>若当前虚拟机启用了偏向锁，那么，当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为01， 即偏向模式。同时使用CAS 操作把获取到这个锁的线程的ID 记录在对象的 Mark Word之中，如果 CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作。</p>
<p>（4）偏向锁、轻量级锁的状态转换及对象Mark Word的关系</p>
<p>当有另一个线程去尝试获取这个锁时，偏向模式就结束了。根据锁对象目前是否处于被锁定的状态， 撤销偏向后恢复到未锁定（标志位为01）或轻量级锁定（标志位为00）的状态，后续的同步操作就如上面介绍的轻量级锁那样执行。</p>
<p>偏向锁、轻量级锁的状态转换及对象Mark Word的关系如图：</p>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8EJVM7.png" alt></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/10/看书笔记/深入理解Java虚拟机/10、字节码执行引擎/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wfc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="只想当扫地机器人的老王">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/10/看书笔记/深入理解Java虚拟机/10、字节码执行引擎/" class="post-title-link" itemprop="url">10、字节码执行引擎</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-10 07:57:02" itemprop="dateCreated datePublished" datetime="2019-07-10T07:57:02+08:00">2019-07-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-09 12:32:42" itemprop="dateModified" datetime="2019-07-09T12:32:42+08:00">2019-07-09</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/看书笔记/" itemprop="url" rel="index"><span itemprop="name">看书笔记</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/看书笔记/深入理解Java虚拟机/" itemprop="url" rel="index"><span itemprop="name">深入理解Java虚拟机</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>所有的Java虚拟机的执行引擎都是一致的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。本节将主要从概念模型的角度来讲解虚拟机的方法调用和字节码执行。</p>
<h2 id="一、运行时栈帧结构（重点）"><a href="#一、运行时栈帧结构（重点）" class="headerlink" title="一、运行时栈帧结构（重点）"></a>一、运行时栈帧结构（重点）</h2><p><strong>栈帧（Stack Frame）</strong> 是用于<em>支持虚拟机方法调用和方法执行</em>的数据结构，它是虚拟机运行时数据区中<strong>虚拟机栈（Virtual Machine Stack）的栈元素</strong>。</p>
<p>栈帧存储了<strong>方法的局部变量表、操作数栈、动态连接和方法返回地址等信息</strong>。每一个方法从调用开始到执行完成的过程，就对应一个栈帧在虚拟机栈里<em>从入栈到出栈</em>的过程。</p>
<p><strong>在编译程序代码的时候，栈帧需要多大的局部变量表、多深的操作数栈都已经完全确定了</strong>，因此一个栈帧需要分配多少内存不会受到运行期变量数据的影响。</p>
<p>活动线程中只有栈顶的栈帧是有效的，称为当前栈帧，执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作。</p>
<p>在活动线程中，只有位于栈顶的栈帧才是有效的，成为当前栈帧，与这个栈帧相关联的方法称为当前方法。执行引擎运行的所有字节码指令都只针对当前栈帧进行操作。</p>
<p>Java 虚拟机每调用一个 Java 方法，便会创建一个栈帧。</p>
<p>这种栈帧有两个主要的组成部分，分别是<strong>局部变量区</strong>，以及字节码的<strong>操作数栈</strong>。这里的局部变量是广义的，除了普遍意义下的局部变量之外，它还包含实例方法的“this指针”以及方法所接收的参数。</p>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E1.png" alt></p>
<h3 id="1、局部变量表"><a href="#1、局部变量表" class="headerlink" title="1、局部变量表"></a>1、局部变量表</h3><h4 id="1-1-作用"><a href="#1-1-作用" class="headerlink" title="1.1.作用"></a>1.1.作用</h4><p>局部变量表是一组变量值存储空间，用于<strong>存放方法参数和方法内定义的局部变量</strong>。程序编译完成时，就在方法的的Code属性的max_locals数据项中定义了该方法的所需分配的局部变量表的最大容量。</p>
<ul>
<li><p>在 Java 虚拟机规范中，局部变量区等价于一个数组，并且可以用正整数来索引。除了 long、double 值需要用两个数组单元来存储之外，其他基本类型以及引用类型的值均占用一个数组单元。</p>
</li>
<li><p>也就是说，boolean、byte、char、short 这四种类型，在栈上占用的空间和 int 是一样的，和引用类型也是一样的。因此，在 32 位的 HotSpot 中，这些类型在栈上将占用 4 个字节；而在 64 位的 HotSpot 中，他们将占 8 个字节。</p>
</li>
</ul>
<p>当然，这种情况仅存在于局部变量，而并不会出现在存储于堆中的字段或者数组元素上。对于 byte、char 以及 short 这三种类型的字段或者数组单元，它们在堆上占用的空间分别为一字节、两字节，以及两字节，也就是说，跟这些类型的值域相吻合。</p>
<h4 id="1-2-存储"><a href="#1-2-存储" class="headerlink" title="1.2.存储"></a>1.2.存储</h4><ol>
<li><p>局部变量表的容量以变量槽(slot)为最小单位，一个slot的内存占用并不确定，但每个slot应该能存放下boolean、byte、char、short、int、float、reference或者returnAddress类型的数据，这些可以使用32位或者更小的物理内存来存放，但允许slot的长度随着处理器、操作系统或者虚拟机的不同而发生变化。</p>
</li>
<li><p>虚拟机对reference类型的要求：一是从此引用中直接或者间接地查找到对象在Java堆中的数据存放的起始索引地址；二是此引用中直接或者间接地查找到对象所属数据类型在方法区中的存储的类型信息。</p>
</li>
<li><p>对于64位数据类型(long、double),虚拟机以高位对齐的方式为其分配两个连续的slot空间。</p>
</li>
</ol>
<h4 id="1-3-局部变量表的使用"><a href="#1-3-局部变量表的使用" class="headerlink" title="1.3.局部变量表的使用"></a>1.3.局部变量表的使用</h4><ul>
<li><p><strong>虚拟机通过索引定位的方式使用局部变量表</strong>，索引值的范围从0开始至局部变量表最大的Slot数量。访问的是32位数据类型的变量，索引n就代表了使用第n个Slot,如果是64位数据类型，就代表会同时使用n和n+1这两个Slot。</p>
</li>
<li><p><strong>为了节省栈帧空间，局部变量Slot可以重用</strong>，方法体中定义的变量，其作用域并不一定会覆盖整个方法体。如果当前字节码PC计数器的值超出了某个变量的作用域，那么这个变量的Slot就可以交给其他变量使用。这样的设计会带来一些额外的副作用，比如：局部变量表作为 GC Roots的一部分，如果局部变量表中对象的引用一直存在或者没有被替换，该对象就不会被GC 回收。</p>
</li>
</ul>
<p>局部变量不会有“准备阶段”，即不会赋予它初始值，一个局部变量如果定义了但是没有赋初始值是不能使用的。</p>
<h2 id="2、操作数栈"><a href="#2、操作数栈" class="headerlink" title="2、操作数栈"></a>2、操作数栈</h2><p>操作数栈也常被称作操作栈，他是后入先出的栈。操作数栈的最大深度也在编译的时候写入到Code属性的max_stacks数据项中。<br>32位的数据类型所占栈容量为1,64位数据类型的栈容量为2。在方法执行的时候，操作数栈的深度不会超过在max_stacks中设定的最大值。</p>
<p><strong>Java 虚拟机的算数运算几乎全部依赖于操作数栈</strong>。也就是说，我们需要将堆中的 boolean、byte、char 以及 short 加载到操作数栈上，而后将栈上的值当成 int 类型来运算。</p>
<ul>
<li><p>当一个方法刚刚开始执行时，方法的操作数栈为空，在方法执行过程中，字节码指令向操作数栈写入和提取内容，也就是出栈、入栈操作。</p>
</li>
<li><p>在概念模型中，一个活动线程中两个栈帧是相互独立的。但大多数虚拟机实现都会做一些优化处理：让下一个栈帧的部分操作数栈与上一个栈帧的部分局部变量表重叠在一起，这样的好处是方法调用时可以共享一部分数据，而无须进行额外的参数复制传递。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E22.png" alt></p>
<h3 id="3、动态链接"><a href="#3、动态链接" class="headerlink" title="3、动态链接"></a>3、动态链接</h3><p>每个栈帧都包含一个执行运行时常量池中该栈帧所属方法的引用，这个引用为了支持调用过程中动态链接（Dynamic linking）。</p>
<p>字节码中方法调用指令是以常量池中的指向方法的符号引用为参数的，有一部分符号引用会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为 静态解析，另外一部分在每次的运行期间转化为直接引用，这部分称为动态连接。</p>
<h3 id="4、方法返回地址"><a href="#4、方法返回地址" class="headerlink" title="4、方法返回地址"></a>4、方法返回地址</h3><p>当一个方法被执行后，有两种方式退出这个方法：</p>
<ul>
<li>第一种是执行引擎遇到任意一个方法返回的字节码指令，这种退出方法的方式称为正常完成出口（Normal Method Invocation Completion）。</li>
<li>另外一种是在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理（即本方法异常处理表中没有匹配的异常处理器），就会导致方法退出，这种退出方式称为异常完成出口（Abrupt Method Invocation Completion）。 注意：这种退出方式不会给上层调用者产生任何返回值。</li>
</ul>
<p><strong>无论采用何种退出方式，在方法退出后，都需要返回到方法被调用的位置，程序才能继续执行</strong>，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是通过异常处理器表来确定的，栈帧中一般不会保存这部分信息。</p>
<p>方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。</p>
<h3 id="5、附加信息"><a href="#5、附加信息" class="headerlink" title="5、附加信息"></a>5、附加信息</h3><p>虚拟机规范允许虚拟机实现向栈帧中添加一些自定义的附加信息，例如与调试相关的信息等。</p>
<p>二、方法调用<br>方法调用阶段唯一的任务就是确定被调用方法的版本（调用的是哪一个方法），暂时还不涉及方法内部的具体运行过程。Class文件的编译过程中不包含传统编译中的连接步骤，一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址（相当于直接引用）这个特性为java带来了更强大的动态扩展能力。</p>
<p>解析</p>
<p>所有方法调用中的目标方法在Class文件里面都是一个常量池的符号引用<strong>，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能成立的条件是方法在程序真正运行之前就有一个可确定的版本</strong>，并且这个方法的调用版本在运行期是不可变的。即调用目标在程序代码写好、编译器进行编译时就必须确定下来。这种调用称为解析。</p>
<p>符合”编译器可知，运行期不变“的方法，主要是静态方法和私有方法。静态方法与类型直接相关，私有方法在外部不可能被访问，因此这两种方法不可能通过继承或别的方法重写其他版本，因此适合在类加载阶段进行解析。</p>
<p>在Java虚拟机中提供了5条方法调用字节码指令：</p>
<p>invokestatic : 调用静态方法<br>invokespecial: 调用实例构造器方法、私有方法、父类方法<br>invokevirtual: 调用所有的虚方法<br>invokeinterface: 调用接口方法，会在运行时在确定一个实现此接口的对象<br>invokedynamic: 先在运行时动态解析出点限定符所引用的方法， 然后再执行该方法，在此之前的4条调用命令的分派逻辑是固化在Java虚拟机内部的， 而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。<br>只要能被invokestatic invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，符合条件的有静态方法、私有方法、实力构造器、父类方法4类。它们在类加载的时候就会把符号引用解析为该方法的直接引用。 这些方法称为非虚方法。final修饰的方法也是非虚方法。</p>
<p>解析是个静态的过程，编译期间就完全确定，在类加载的解析阶段会把涉及的符号引用全部转为直接引用，不会延迟到运行期再去完成</p>
<h2 id="三、基于栈的字节码解释执行引擎"><a href="#三、基于栈的字节码解释执行引擎" class="headerlink" title="三、基于栈的字节码解释执行引擎"></a>三、基于栈的字节码解释执行引擎</h2><p>虚拟机如何调用方法的内容已经讲解完毕，现在我们来探讨虚拟机是如何执行方法中的字节码指令。</p>
<h3 id="1、解释执行"><a href="#1、解释执行" class="headerlink" title="1、解释执行"></a>1、解释执行</h3><p>Java语言经常被人们定位为“解释执行”语言，在Java初生的JDK1.0时代，这种定义还比较准确的，但当主流的虚拟机中都包含了即时编译后，Class文件中的代码到底会被解释执行还是编译执行，就成了只有虚拟机自己才能准确判断的事情。再后来，Java也发展出来了直接生成本地代码的编译器[如何GCJ（GNU Compiler for the Java）]，而C/C++也出现了通过解释器执行的版本（如CINT），这时候再笼统的说“解释执行”，对于整个Java语言来说就成了几乎没有任何意义的概念。</p>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E3.png" alt></p>
<h3 id="2、基于栈的指令集与基于寄存器的指令集"><a href="#2、基于栈的指令集与基于寄存器的指令集" class="headerlink" title="2、基于栈的指令集与基于寄存器的指令集"></a>2、基于栈的指令集与基于寄存器的指令集</h3><p>Java编译器输出的指令流，基本上是一种基于栈的指令集架构（Instruction Set Architecture，ISA），指令流中的指令大部分都是零地址指令，它们依赖操作数栈进行工作。与之相对应的另一套常用的指令集架构是基于寄存器的指令集，最典型的就是X86的地址指令集，说的通俗一下，就是现在我们主流的PC机中直接支持的指令集架构，这些指令集依赖寄存器工作。</p>
<p>例子：如下分别使用两种指令集计算“1+1”的结果：</p>
<p>基于栈的指令集：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iconst_1 iconst_1 iadd istore_0</span><br></pre></td></tr></table></figure>

<p>两条 iconst_1 指令连续把两个常量1压入操作栈后，<br>iadd指令把栈顶的两个值出栈、相加，然后把结果放回栈顶，最后istore_0把栈顶值放到局部变量表的第0个Slot中。</p>
<p>基于寄存器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax，1 add eax，1</span><br></pre></td></tr></table></figure>

<p>mov指令把EAX寄存器的值设为1，然后add指令再把值加1，结果就保存在EAX寄存器里面。</p>
<p>两套指令集的优缺点：</p>
<p>基于栈的指令集主要的优点就是可移植性，不会受硬件的不同而受影响。而基于寄存器的指令集，程序直接依赖这些硬件寄存器，不同的硬件设备，则不可避免受到约束。而使用栈架构的指令集，用户程序不会直接使用这些寄存器，而是由虚拟机来完成与寄存器的交互，从而避免直接与硬件交互。但基于栈指令集的主要缺点是执行速度相对来说会稍慢一些。而相对的基于寄存器指令集的执行速度会相对较优。</p>
<h3 id="3、基于栈的解释器执行过程"><a href="#3、基于栈的解释器执行过程" class="headerlink" title="3、基于栈的解释器执行过程"></a>3、基于栈的解释器执行过程</h3><p>通过如下代码解释基于栈的解释器执行过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public int calc() &#123;</span><br><span class="line">        int a = 100;</span><br><span class="line">        int b = 200;</span><br><span class="line">        int c = 300;</span><br><span class="line">        return (a + b) * c;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>使用javap命令后得如下反编译代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public int calc();</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=4, args_size=1</span><br><span class="line">         0: bipush  100</span><br><span class="line">         2: istore_1</span><br><span class="line">         3: sipush  200</span><br><span class="line">         6: istore_2</span><br><span class="line">         7: sipush  300</span><br><span class="line">        10: istore_3</span><br><span class="line">        11: iload_1</span><br><span class="line">        12: iload_2</span><br><span class="line">        13: iadd</span><br><span class="line">        14: iload_3</span><br><span class="line">        15: imul</span><br><span class="line">        16: ireturn</span><br></pre></td></tr></table></figure>

<p>javap提示这段代码需要深度为2的操作数栈和4个Slot的局部变量空间，根据这些信息总共可绘制7张图来描述程序执行过程中的代码、 操作数栈和局部变量表的变化情况：</p>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E4.png" alt></p>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E5.png" alt></p>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E6.png" alt></p>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E77.png" alt></p>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E8.png" alt></p>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E9.png" alt></p>
<h2 id="四、字节码介绍"><a href="#四、字节码介绍" class="headerlink" title="四、字节码介绍"></a>四、字节码介绍</h2><p>Java虚拟机指令由一个字节长度的、代表某种特定操作含义的数字（操作码）以及跟随其后的零至多个代表此操作所需的参数构成。</p>
<h3 id="1、字节码与数据类型"><a href="#1、字节码与数据类型" class="headerlink" title="1、字节码与数据类型"></a>1、字节码与数据类型</h3><p>Java虚拟机的指令由一个字节长度，代表着某种特定操作含义的数字（称为操作码）以及跟其随后的零至多个代表此操作所需参数（称为操作数）而构成。Java虚拟机采用面向操作数栈而不是寄存器的架构，所以大多数指令都不包含操作数。因为字节码指令只有一个字节，所以指令集的操作码总数不可能超过256条。</p>
<p>在Java虚拟机中，大多数的指令都包含了其对操作所对应的数据类型信息。对于大部分与数据类型相关的字节码指令，他们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务。i代表int l代表long,s代表short,b代表byte,c代表char,f代表float,a代表reference.</p>
<h3 id="2、加载和存储指令"><a href="#2、加载和存储指令" class="headerlink" title="2、加载和存储指令"></a>2、加载和存储指令</h3><p>加载存储指令用于将数据在帧栈中的局部变量表和操作数栈进行来回传输。</p>
<p>①将一个局部变量加载到操作栈：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iload，iload&lt;n&gt;,lload,lload&lt;n&gt;,fload,fload&lt;n&gt;,dload,dload&lt;n&gt;,aload,aload&lt;n&gt;</span><br></pre></td></tr></table></figure>

<p>②将一个数值从操作数栈存储到局部变量表中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">istore,istore&lt;n&gt;,lstore,lstore&lt;n&gt;,fstore,fstore&lt;n&gt;,dstore,dstore&lt;n&gt;,adore,adore&lt;n&gt;</span><br></pre></td></tr></table></figure>

<p>③将一个常量加载到操作数栈中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bipush,sipush,ldc,ldc_w,ldc2_w,aconst_null,iconst_m1,iconst_&lt;i&gt;,fconst_&lt;i&gt;,dconst_&lt;i&gt;.</span><br></pre></td></tr></table></figure>

<p>④扩充局部变量的访问索引的指令。wide.</p>
<h3 id="3、运算指令"><a href="#3、运算指令" class="headerlink" title="3、运算指令"></a>3、运算指令</h3><p>运算或算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。注意：由于没有直接支持byte,short,char和boolean类型的算术运算指令，对这种类型直接转换为int进行运算。特别需要注意的是：数据运算可能会导致溢出对象，Java虚拟机在整数没有定义数据异常，所以整数异常不报异常，注意在编程中范围。</p>
<ul>
<li>加法指令：iadd,ladd,fadd,dadd 减法指令:isub,lsub,fsub,dsub</li>
<li>乘法指令：imul，lmul,fmul,dmul</li>
<li>除法指令：idiv,ldiv,fdiv,ddiv</li>
<li>求于指令：irem,lrem,frem,drem</li>
<li>取反指令：ineg,lneg,fneg,dneg</li>
<li>位移指令：iishl,lishl,fishl,dishl 按位或指令:ior,lor</li>
<li>按位与指令:land,land 按位异或指令:ixor,lxor</li>
<li>局部变量自增指令:inc 比较指令:dcmpg,dcmpl,fcmpg,fcmpl,lcmp</li>
</ul>
<p>注意：</p>
<ol>
<li><p>Java虚拟机在处理浮点数运算时，不会抛出任何运行时异常，当一个操作产生溢出时，将会使用有符号的无穷大来表示。操作结果没有明确的数学定义的话，将会时候NaN值来表示。</p>
</li>
<li><p>在处理整型数据时，只有除法指令（idiv和ldiv）以及求余指令（irem和lrem）出现除数为零时会导致虚拟机抛出异常</p>
</li>
</ol>
<h3 id="4、类型转换指令"><a href="#4、类型转换指令" class="headerlink" title="4、类型转换指令"></a>4、类型转换指令</h3><p>类型转换指令可以将两种不同的数值类型进行相互转换，一般用于实现用户代码中的显式类型转换操作。</p>
<p>一、</p>
<ol>
<li>int类型到long、float或者double类型</li>
<li>long类型到float、double类型</li>
<li>float类型到double类型</li>
</ol>
<p>二、</p>
<ol>
<li>宽化类型转换指令包括：i2l, i2f, i2d, l2f, l2d, f2d</li>
<li>窄化类型转换:指令包括有：i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l和d2f。窄化类型转换可能会导致转换结果产生不同的正负号、不同的数量级，转换过程很可能会导致数值丢失精度。</li>
</ol>
<h3 id="5、对象创建与访问指令"><a href="#5、对象创建与访问指令" class="headerlink" title="5、对象创建与访问指令"></a>5、对象创建与访问指令</h3><p>虽然类实例和数组都是对象，但Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令。</p>
<ol>
<li>new ：创建类实例的指令。</li>
<li>newarray、anewarray、multianewarray：创建数组的指令。</li>
<li>getstatic、putstatic、getfield、putfield：访问类字段（类变量）和实例字段（实例变量）的指令。</li>
<li>baload、caload、saload、iaload、laload、faload、daload、aaload：把一个数组元素加载到操作数栈的指令。</li>
<li>bastore、castore、sastore、iastore、lastore、fastore、dastore、aastore：把一个操作数栈的值存储到数组元素中的指令。</li>
<li>arraylength：取数组长度的指令。</li>
<li>instanceof、checkcast：检查类实例类型的指令。</li>
</ol>
<h3 id="6、控制转移指令"><a href="#6、控制转移指令" class="headerlink" title="6、控制转移指令"></a>6、控制转移指令</h3><p>控制转移指令可以让Java虚拟机有条件或无条件地从指定指令而不是控制转移指令的下一条指令继续执行程序。控制转移指令包括有：</p>
<ol>
<li>ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq、if_acmpne：条件分支。</li>
<li>tableswitch、lookupswitch：复合条件分支。</li>
<li>goto、goto_w、jsr、jsr_w、ret：无条件分支。</li>
</ol>
<h3 id="7、操作数栈管理指令"><a href="#7、操作数栈管理指令" class="headerlink" title="7、操作数栈管理指令"></a>7、操作数栈管理指令</h3><p>java虚拟机提供了一些用于直接操作操作数栈的指令</p>
<ol>
<li>pop、pop2：将操作数栈的栈顶一个或两个元素出栈。</li>
<li>dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2：复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶。</li>
<li>swap：将栈最顶端两个数值互换。</li>
</ol>
<h3 id="8、控制转移指令"><a href="#8、控制转移指令" class="headerlink" title="8、控制转移指令"></a>8、控制转移指令</h3><ol>
<li>ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq、if_acmpne：条件分支。</li>
<li>tableswitch、lookupswitch：复合条件分支。</li>
<li>goto、goto_w、jsr、jsr_w、ret：无条件分支。</li>
</ol>
<h3 id="9、方法调用和返回指令"><a href="#9、方法调用和返回指令" class="headerlink" title="9、方法调用和返回指令"></a>9、方法调用和返回指令</h3><p>方法调用：</p>
<ol>
<li>invokestatic：调用静态方法。</li>
<li>invokespecial：调用实例构造器方法、私有方法和父类方法。</li>
<li>invokevirtual：调用所有的虚方法。非虚方法以外的都是虚方法，非虚方法包括使用invokestatic、invokespecial调用的方法和被final修饰的方法。</li>
<li>invokeinterface：调用接口方法，运行时再确定一个实现此接口的对象。</li>
<li>invokedynamic：用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法。<br>返回值指令：<br>ireturn（返回值是boolean、byte、char、short、int）、lreturn、freturn、dreturn、areturn：方法返回指令。</li>
</ol>
<h3 id="10、异常处理指令"><a href="#10、异常处理指令" class="headerlink" title="10、异常处理指令"></a>10、异常处理指令</h3><p>在程序中显式抛出异常的操作会由athrow指令实现，除了这种情况，还有别的异常会在其他Java虚拟机指令检测到异常状况时由虚拟机自动抛出。</p>
<p>athrow ：显式抛出异常指令。</p>
<h4 id="11、同步指令"><a href="#11、同步指令" class="headerlink" title="11、同步指令"></a>11、同步指令</h4><p>Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程（Monitor）来支持的。</p>
<ul>
<li><p>同步一段指令集序列通常是由Java语言中的synchronized块来表示的，Java虚拟机的指令集中有monitorenter和monitorexit两条指令来支持synchronized关键字的语义.</p>
</li>
<li><p>monitorenter、monitorexit：支持synchronized语句块语义的指令。</p>
</li>
</ul>
<h2 id="五、指令"><a href="#五、指令" class="headerlink" title="五、指令"></a>五、指令</h2><p>具体来说，Java 字节码中与调用相关的指令共有五种。</p>
<ol>
<li>invokestatic：用于调用静态方法。</li>
<li>invokespecial：用于调用私有实例方法、构造器，以及使用 super 关键字调用父类的实例方法或构造器，和所实现接口的默认方法。</li>
<li>invokevirtual：用于调用非私有实例方法。</li>
<li>invokeinterface：用于调用接口方法。</li>
<li>invokedynamic：用于调用动态方法。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">interface 客户 &#123;</span><br><span class="line">  boolean isVIP();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class 商户 &#123;</span><br><span class="line">  public double 折后价格 (double 原价, 客户 某客户) &#123;</span><br><span class="line">    return 原价 * 0.8d;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class 奸商 extends 商户 &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public double 折后价格 (double 原价, 客户 某客户) &#123;</span><br><span class="line">    if (某客户.isVIP()) &#123;                         // invokeinterface      </span><br><span class="line">      return 原价 * 价格歧视 ();                    // invokestatic</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return super. 折后价格 (原价, 某客户);          // invokespecial</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  public static double 价格歧视 () &#123;</span><br><span class="line">    // 咱们的杀熟算法太粗暴了，应该将客户城市作为随机数生成器的种子。</span><br><span class="line">    return new Random()                          // invokespecial</span><br><span class="line">           .nextDouble()                         // invokevirtual</span><br><span class="line">           + 0.8d;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-虚方法调用"><a href="#1-虚方法调用" class="headerlink" title="1. 虚方法调用"></a>1. 虚方法调用</h3><p>Java 里所有非私有实例方法调用都会被编译成 invokevirtual 指令，而接口方法调用都会    被编译成 invokeinterface 指令。这两种指令，均属于Java 虚拟机中的虚方法调用。</p>
<p>在绝大多数情况下，Java 虚拟机需要根据调用者的动态类型，来确定虚方法调用的目标方法。这个过程我们称之为动态绑定。那么，相对于静态绑定的非虚方法调用来说，虚方法调用更加耗时。</p>
<p>在 Java 虚拟机中，静态绑定包括用于调用静态方法的 invokestatic 指令，和用于调用构造器、私有实例方法以及超类非私有实例方法的 invokespecial 指令。如果虚方法调用指向一个标记为 final 的方法，那么 Java 虚拟机也可以静态绑定该虚方法调用的目标方法。</p>
<p>Java 虚拟机中采取了一种用空间换取时间的策略来实现动态绑定。它为每个类生成一张方法表，用以快速定位目标方法。</p>
<h3 id="2-方法表"><a href="#2-方法表" class="headerlink" title="2. 方法表"></a>2. 方法表</h3><p>类加载的准备阶段，它除了为静态字段分配内存之外，还会构造与该类相关联的方法表。</p>
<p>这个数据结构，便是 Java 虚拟机实现动态绑定的关键所在。下面我将以 invokevirtual 所使用的虚方法表（virtual method table，vtable）为例介绍方法表的用法。invokeinterface 所使用的接口方法表（interface method table，itable）稍微复杂些，但是原理其实是类似的。</p>
<p>方法表本质上是一个数组，每个数组元素指向一个当前类及其祖先类中非私有的实例方法。</p>
<p>这些方法可能是具体的、可执行的方法，也可能是没有相应字节码的抽象方法。方法表满足两个特质：</p>
<p>其一，子类方法表中包含父类方法表中的所有方法；<br>其二，子类方法在方法表中的索引值，与它所重写的父类方法的索引值相同。<br>我们知道，方法调用指令中的符号引用会在执行之前解析成实际引用。对于静态绑定的方法调用而言，实际引用将指向具体的目标方法。对于动态绑定的方法调用而言，实际引用则是方法表的索引值（实际上并不仅是索引值）。</p>
<p>在执行过程中，Java 虚拟机将获取调用者的实际类型，并在该实际类型的虚方法表中，根据索引值获得目标方法。这个过程便是动态绑定。</p>
<p>使用了方法表的动态绑定与静态绑定相比，仅仅多出几个内存解引用操作：访问栈上的调用者，读取调用者的动态类型，读取该类型的方法表，读取方法表中某个索引值所对应的目标方法。相对于创建并初始化 Java 栈帧来说，这几个内存解引用操作的开销简直可以忽略不计</p>
<p>那么我们是否可以认为虚方法调用对性能没有太大影响呢？</p>
<p>其实是不能的，上述优化的效果看上去十分美好，但实际上仅存在于解释执行中，或者即时编译代码的最坏情况中。这是因为即时编译还拥有另外两种性能更好的优化手段：内联缓存（inlining cache）和方法内联（method inlining）。</p>
<h3 id="3-内联缓存"><a href="#3-内联缓存" class="headerlink" title="3. 内联缓存"></a>3. 内联缓存</h3><p>内联缓存是一种加快动态绑定的优化技术。它能够缓存虚方法调用中调用者的动态类型，以及该类型所对应的目标方法。在之后的执行过程中，如果碰到已缓存的类型，内联缓存便会直接调用该类型所对应的目标方法。如果没有碰到已缓存的类型，内联缓存则会退化至使用基于方法表的动态绑定。</p>
<p>即：</p>
<p>Java 虚拟机中的即时编译器会使用内联缓存来加速动态绑定。Java 虚拟机所采用的单态内联缓存将纪录调用者的动态类型，以及它所对应的目标方法。</p>
<p>当碰到新的调用者时，如果其动态类型与缓存中的类型匹配，则直接调用缓存的目标方法。否则，Java 虚拟机将该内联缓存劣化为超多态内联缓存，在今后的执行过程中直接使用方法表进行动态绑定。</p>
<p>在针对多态的优化手段中，我们通常会提及以下三个术语。</p>
<ol>
<li>单态（monomorphic）指的是仅有一种状态的情况。</li>
<li>多态（polymorphic）指的是有限数量种状态的情况。二态（bimorphic）是多态的其中一种。</li>
<li>超多态（megamorphic）指的是更多种状态的情况。通常我们用一个具体数值来区分多态和超多态。在这个数值之下，我们称之为多态。否则，我们称之为超多态。</li>
</ol>
<p>对于内联缓存来说，我们也有对应的单态内联缓存、多态内联缓存和超多态内联缓存。单态内联缓存，顾名思义，便是只缓存了一种动态类型以及它所对应的目标方法。它的实现非常简单：比较所缓存的动态类型，如果命中，则直接调用对应的目标方法。</p>
<ul>
<li><p>多态内联缓存则缓存了多个动态类型及其目标方法。它需要逐个将所缓存的动态类型与当前动态类型进行比较，如果命中，则调用对应的目标方法。</p>
</li>
<li><p>一般来说，我们会将更加热门的动态类型放在前面。在实践中，大部分的虚方法调用均是单态的，也就是只有一种动态类型。为了节省内存空间，Java 虚拟机只采用单态内联缓存。</p>
</li>
<li><p>前面提到，当内联缓存没有命中的情况下，Java 虚拟机需要重新使用方法表进行动态绑定。对于内联缓存中的内容，我们有两种选择。一是替换单态内联缓存中的纪录。这种做法就好比 CPU 中的数据缓存，它对数据的局部性有要求，即在替换内联缓存之后的一段时间内，方法调用的调用者的动态类型应当保持一致，从而能够有效地利用内联缓存。</p>
</li>
<li><p>因此，在最坏情况下，我们用两种不同类型的调用者，轮流执行该方法调用，那么每次进行方法调用都将替换内联缓存。也就是说，只有写缓存的额外开销，而没有用缓存的性能提升。</p>
</li>
<li><p>另外一种选择则是劣化为超多态状态。这也是 Java 虚拟机的具体实现方式。处于这种状态下的内联缓存，实际上放弃了优化的机会。它将直接访问方法表，来动态绑定目标方法。与替换内联缓存纪录的做法相比，它牺牲了优化的机会，但是节省了写缓存的额外开销。</p>
</li>
<li><p>虽然内联缓存附带内联二字，但是它并没有内联目标方法。这里需要明确的是，任何方法调用除非被内联，否则都会有固定开销。这些开销来源于保存程序在该方法中的执行位置，以及新建、压入和弹出新方法所使用的栈帧。</p>
</li>
<li><p>对于极其简单的方法而言，比如说 getter/setter，这部分固定开销占据的 CPU 时间甚至超过了方法本身。此外，在即时编译中，方法内联不仅仅能够消除方法调用的固定开销，而且还增加了进一步优化的可能性.</p>
</li>
</ul>
<h2 id="六、调用指令的符号引用"><a href="#六、调用指令的符号引用" class="headerlink" title="六、调用指令的符号引用"></a>六、调用指令的符号引用</h2><p>在编译过程中，我们并不知道目标方法的具体内存地址。因此，Java 编译器会暂时用符号引用来表示该目标方法。这一符号引用包括目标方法所在的类或接口的名字，以及目标方法的方法名和方法描述符。</p>
<p>符号引用存储在 class 文件的常量池之中。根据目标方法是否为接口方法，这些引用可分为接口符号引用和非接口符号引用。</p>
<p>对于非接口符号引用，假定该符号引用所指向的类为 C，则 Java 虚拟机会按照如下步骤进行查找。</p>
<ol>
<li>在 C 中查找符合名字及描述符的方法。</li>
<li>如果没有找到，在 C 的父类中继续搜索，直至 Object 类。</li>
<li>如果没有找到，在 C 所直接实现或间接实现的接口中搜索，这一步搜索得到的目标方法必须是非私有、非静态的。并且，如果目标方法在间接实现的接口中，则需满足 C 与该接口之间没有其他符合条件的目标方法。如果有多个符合条件的目标方法，则任意返回其中一个。</li>
<li>从这个解析算法可以看出，静态方法也可以通过子类来调用。此外，子类的静态方法会隐藏（注意与重写区分）父类中的同名、同描述符的静态方法。</li>
</ol>
<p>对于接口符号引用，假定该符号引用所指向的接口为 I，则 Java 虚拟机会按照如下步骤进行查找。</p>
<ol>
<li>在 I 中查找符合名字及描述符的方法。</li>
<li>如果没有找到，在 Object 类中的公有实例方法中搜索。</li>
<li>如果没有找到，则在 I 的超接口中搜索。这一步的搜索结果的要求与非接口符号引用步骤 3 的要求一致。</li>
</ol>
<p>经过上述的解析步骤之后，符号引用会被解析成实际引用。对于可以静态绑定的方法调用而言，实际引用是一个指向方法的指针。对于需要动态绑定的方法调用而言，实际引用则是一个方法表的索引。</p>
<h2 id="七、公有设计和私有实现"><a href="#七、公有设计和私有实现" class="headerlink" title="七、公有设计和私有实现"></a>七、公有设计和私有实现</h2><p>Java虚拟机规范描绘了Java虚拟机应有的共同程序存储格式：Class文件格式以及字节码指令集。这些内容与硬件、操作系统及具体的Java虚拟机实现之间是完全独立的，虚拟机实现者可能更愿意把他们看作是程序在各种Java平台实现之间互相安全的交互的手段。</p>
<p>理解公有设计与私有实现之间的分界线是非常有必要的，Java虚拟机实现必须能够读取Class文件并精确实现包含在其中的Java虚拟机代码的语义。拿着Java虚拟机规范一成不变的逐字实现其中要求的内容当然是一种可行的途径，但一个优秀的虚拟机实现，在满足虚拟机规范的约束下对具体实现做出修改和优化也是完全可行的，并且虚拟机规范中明确鼓励实现者这样做。只要优化后Class文件依然可以被正确读取，并且包含在其中的语义能得到完整的保持，那实现者就可以选择任何方式去实现这些语义，虚拟机后台如何处理Class文件完全是实现者自己的事情，只要他在外部接口上看起来与规范描述的一致即可。</p>
<p>虚拟机实现者可以使用这种伸缩新来让Java虚拟机获得更高的性能、更低的内存消耗或者更好的可移植性，选择哪种特性取决于Java虚拟机实现的目标和关注点是什么。虚拟机实现的方式主要有以下两种：</p>
<ul>
<li><strong>将输入的Java虚拟机代码在加载或执行时翻译成另外一种虚拟机的指令集。</strong></li>
<li><strong>将输入的Java虚拟机代码在加载或执行时翻译成宿主CPU的本地指令集（即JIT代码生成技术）。</strong></li>
</ul>
<p>精确定义的虚拟机和目标文件格式不应当对虚拟机实现者的创造性产生太多的限制，Java虚拟机因被设计成可以允许有众多不同的实现，并且各种实现可以在保持兼容性的同时提供不同的、新的、有趣的解决方案。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/10/看书笔记/深入理解Java虚拟机/9、静态分派和动态分派/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wfc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="只想当扫地机器人的老王">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/10/看书笔记/深入理解Java虚拟机/9、静态分派和动态分派/" class="post-title-link" itemprop="url">9、静态分派和动态分派</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-10 07:57:02" itemprop="dateCreated datePublished" datetime="2019-07-10T07:57:02+08:00">2019-07-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-09 10:25:40" itemprop="dateModified" datetime="2019-07-09T10:25:40+08:00">2019-07-09</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/看书笔记/" itemprop="url" rel="index"><span itemprop="name">看书笔记</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/看书笔记/深入理解Java虚拟机/" itemprop="url" rel="index"><span itemprop="name">深入理解Java虚拟机</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1、基础知识点"><a href="#1、基础知识点" class="headerlink" title="1、基础知识点"></a>1、基础知识点</h2><h3 id="1-1-分派"><a href="#1-1-分派" class="headerlink" title="1.1 分派"></a>1.1 分派</h3><p>定义：确定执行哪个方法的过程<br>分类：静态分派 &amp; 动态分派</p>
<p>a. 疑问</p>
<p>方法的执行不是取决于代码设置中的执行对象吗？为什么还要选择呢？</p>
<p>b. 回答</p>
<ul>
<li>若 一个对象对应于多个方法 时，就需要进行选择了</li>
<li>Java中的特性：多态，即重写 &amp; 重载。</li>
</ul>
<h3 id="1-2-变量的静态类型-amp-动态类型"><a href="#1-2-变量的静态类型-amp-动态类型" class="headerlink" title="1.2 变量的静态类型 &amp; 动态类型"></a>1.2 变量的静态类型 &amp; 动态类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123; </span><br><span class="line"></span><br><span class="line">    static abstract class Human &#123; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    static class Man extends Human &#123; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    static class Woman extends Human &#123; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">// 执行代码</span><br><span class="line">public static void main(String[] args) &#123; </span><br><span class="line"></span><br><span class="line">  Human man = new Man(); </span><br><span class="line">  // 变量man的静态类型 = 引用类型 = Human：不会被改变、在编译器可知</span><br><span class="line">  // 变量man的动态类型 = 实例对象类型 = Man：会变化、在运行期才可知</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>变量的静态类型 = 引用类型 ：不会被改变、在编译器可知</strong></p>
<p><strong>变量的动态类型 = 实例对象类型 ：会变化、在运行期才可知</strong></p>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E9%9D%99%E6%80%81%E5%88%86%E6%B4%BE%E5%92%8C%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE1.jpg" alt></p>
<h2 id="2、静态分派"><a href="#2、静态分派" class="headerlink" title="2、静态分派"></a>2、静态分派</h2><p>定义: </p>
<ol>
<li>根据变量的静态类型进行方法分派的行为即根据 变量的静态类型确定执行哪个方法</li>
<li>发生在编译期，所以不由 Java 虚拟机来执行</li>
</ol>
<p>应用场景</p>
<p>方法重载（OverLoad） = 静态分派 = 根据 变量的静态类型确定执行（重载）哪个方法。</p>
<p>什么是重载？</p>
<p>如果我们想要在同一个类中定义名字相同的方法，那么它们的参数类型必须不同。这些方法之间的关系，我们称之为重载。重载的方法在编译过程中即可完成识别。具体到每一个方法调用，Java 编译器会根据所传入参数的声明类型（注意与实际类型区分）来选取重载方法。选取的过程共分为三个阶段：</p>
<ol>
<li>在不考虑对基本类型自动装拆箱（auto-boxing，auto-unboxing），以及可变长参数的情况下选取重载方法；</li>
<li>如果在第 1 个阶段中没有找到适配的方法，那么在允许自动装拆箱，但不允许可变长参数的情况下选取重载方法；</li>
<li>如果在第 2 个阶段中没有找到适配的方法，那么在允许自动装拆箱以及可变长参数的情况下选取重载方法。</li>
</ol>
<p>如果 Java 编译器在同一个阶段中找到了多个适配的方法，那么它会在其中选择一个最为贴切的，而决定贴切程度的一个关键就是形式参数类型的继承关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123; </span><br><span class="line"></span><br><span class="line">// 类定义</span><br><span class="line">    static abstract class Human &#123; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">// 继承自抽象类Human</span><br><span class="line">    static class Man extends Human &#123; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    static class Woman extends Human &#123; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">// 可供重载的方法</span><br><span class="line">    public void sayHello(Human guy) &#123; </span><br><span class="line">        System.out.println(&quot;hello,guy!&quot;); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    public void sayHello(Man guy) &#123; </span><br><span class="line">        System.out.println(&quot;hello gentleman!&quot;); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    public void sayHello(Woman guy) &#123; </span><br><span class="line">        System.out.println(&quot;hello lady!&quot;); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">// 测试代码</span><br><span class="line">    public static void main(String[] args) &#123; </span><br><span class="line">        Human man = new Man(); </span><br><span class="line">        Human woman = new Woman(); </span><br><span class="line">        Test test = new Test(); </span><br><span class="line"></span><br><span class="line">        test.sayHello(man);  //man修饰的是Human</span><br><span class="line">        test.sayHello(woman); //woman修饰的是Human</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 运行结果</span><br><span class="line">hello,guy! </span><br><span class="line">hello,guy!</span><br></pre></td></tr></table></figure>

<p>特别注意</p>
<p>a. 变量的静态类型发生变化的情况</p>
<p>可通过强制类型转换改变变量的静态类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Human man = new Man(); </span><br><span class="line">test.sayHello((Man)man); </span><br><span class="line">// 强制类型转换</span><br><span class="line">// 此时man的静态类型从 Human 变为 Man</span><br><span class="line"></span><br><span class="line">// 所以会调用sayHello()中参数为Man guy的方法，即sayHello(Man guy)</span><br></pre></td></tr></table></figure>

<p>b. 静态分派的优先级匹配问题</p>
<p>问题描述：</p>
<p>背景：现需要进行静态分派</p>
<p>问题：程序中没有显示指 静态类型</p>
<p>解决方案：程序会根据<strong>静态类型的优先级</strong>从而选择优先的静态类型进行方法分配。</p>
<p>特别注意</p>
<ul>
<li>上面讲解的主要是基本数据类型的优先级匹配问题</li>
<li>若是引用类型，则根据继承关系进行优先级匹配</li>
</ul>
<p>注意只跟其编译时类型（即静态类型）相关</p>
<p>优先级顺序为：</p>
<ul>
<li>char &gt; int &gt; long &gt; float &gt; double &gt; Character &gt; Serializable &gt; Object &gt;…</li>
<li>其中…为变长参数，将其视为一个数组元素。变长参数的重载优先级最低。 因为 char 转型到 byte 或 short 的过程是不安全的 所以不会选择参数类型为byte</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//比如：</span><br><span class="line">public class Overload &#123;  </span><br><span class="line">      </span><br><span class="line">    private static void sayHello(char arg)&#123;  </span><br><span class="line">        System.out.println(&quot;hello char&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    private static void sayHello(Object arg)&#123;  </span><br><span class="line">        System.out.println(&quot;hello Object&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    private static void sayHello(int arg)&#123;  </span><br><span class="line">        System.out.println(&quot;hello int&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    private static void sayHello(long arg)&#123;  </span><br><span class="line">        System.out.println(&quot;hello long&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">// 测试代码</span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">          </span><br><span class="line">        sayHello(&apos;a&apos;);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">// 运行结果</span><br><span class="line">hello char</span><br></pre></td></tr></table></figure>

<h2 id="3、动态分派"><a href="#3、动态分派" class="headerlink" title="3、动态分派"></a>3、动态分派</h2><h3 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h3><p>根据 变量的动态类型进行方法分派的行为</p>
<p>即根据 变量的动态类型确定执行哪个方法</p>
<h3 id="3-2-应用场景"><a href="#3-2-应用场景" class="headerlink" title="3.2 应用场景"></a>3.2 应用场景</h3><p>方法重写（Override）</p>
<p>如果子类定义了与父类中非私有、非静态方法同名的方法，那么只有当这两个方法的参数类型以及返回类型一致，Java 虚拟机才会判定为重写。</p>
<p>对于 Java 语言中重写而 Java 虚拟机中非重写的情况，编译器会通过生成桥接方法 来实现 Java 中的重写语义。</p>
<p>由于对重载方法的区分在编译阶段已经完成，我们可以认为 Java 虚拟机不存在重载这一概念。</p>
<p>确切地说，Java 虚拟机中的静态绑定指的是在解析时便能够直接识别目标方法的情况，而动态绑定则指的是需要在运行过程中根据调用者的动态类型来识别目标方法的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// 定义类</span><br><span class="line">    class Human &#123; </span><br><span class="line">        public void sayHello()&#123; </span><br><span class="line">            System.out.println(&quot;Human say hello&quot;); </span><br><span class="line"> </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">// 继承自 抽象类Human 并 重写sayHello()</span><br><span class="line">    class Man extends Human &#123; </span><br><span class="line">        @Override </span><br><span class="line">        protected void sayHello() &#123; </span><br><span class="line">            System.out.println(&quot;man say hello&quot;); </span><br><span class="line"> </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    class Woman extends Human &#123; </span><br><span class="line">        @Override </span><br><span class="line">        protected void sayHello() &#123; </span><br><span class="line">            System.out.println(&quot;woman say hello&quot;); </span><br><span class="line"> </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">// 测试代码</span><br><span class="line">    public static void main(String[] args) &#123; </span><br><span class="line"></span><br><span class="line">        // 情况1</span><br><span class="line">        Human man = new man(); </span><br><span class="line">        man.sayHello(); </span><br><span class="line"></span><br><span class="line">        // 情况2</span><br><span class="line">        man = new Woman(); </span><br><span class="line">        man.sayHello(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 运行结果</span><br><span class="line">man say hello</span><br><span class="line">woman say hello</span><br><span class="line"></span><br><span class="line">// 原因解析</span><br><span class="line">// 1. 方法重写（Override） = 动态分派 = 根据 变量的动态类型 确定执行（重写）哪个方法</span><br><span class="line">// 2. 对于情况1：根据变量（Man）的动态类型（man）确定调用man中的重写方法sayHello()</span><br><span class="line">// 3. 对于情况2：根据变量（Man）的动态类型（woman）确定调用woman中的重写方法sayHello()</span><br></pre></td></tr></table></figure>

<p>invokevirtual指令执行的第一步 = 确定接受者的实际类型</p>
<p>invokevirtual指令执行的第二步 = 将 常量池中 类方法符号引用 解析到不同的直接引用上</p>
<p>第二步即方法重写（Override）的本质</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">例子：静态+动态</span><br><span class="line">A ab = new B(); 这里ab的引用类型是A，但是它指向的内存是类型为B的一个实例。</span><br><span class="line">ab.show(b)执行的时候：</span><br><span class="line">1、首先编译期调用的方法都必须在 class A里面有的才行（因为你的引用类型为A）这里 class A有show(A obj) show(D obj)着两个方法。选择了show(A obj) （因为A是B的父类，向上转型）。这边是静态。</span><br><span class="line">2、运行期ab.show(b)执行show(A obj)的适合，发现ab内存地址指向一个类型为B内存空间，如果class B Override 了 class A的show(A obj)方法，则调用B的方法而不是直接使用show(B obj)，这边是动态。</span><br><span class="line"></span><br><span class="line">class A &#123;  </span><br><span class="line">    public String show(D obj)&#123;  </span><br><span class="line">           return (&quot;A and D&quot;);  </span><br><span class="line">    &#125;   </span><br><span class="line">    public String show(A obj)&#123;  </span><br><span class="line">           return (&quot;A and A&quot;);  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;   </span><br><span class="line">class B extends A&#123; </span><br><span class="line">    public String show(A obj)&#123;  </span><br><span class="line">           return (&quot;B and A&quot;);  </span><br><span class="line">    &#125;   </span><br><span class="line">    public String show(B obj)&#123;  </span><br><span class="line">           return (&quot;B and B&quot;);  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">public class MultiTest&#123; </span><br><span class="line">public static void main(String[] args)&#123; </span><br><span class="line">        A ab = new B();  </span><br><span class="line">        B b = new B();  </span><br><span class="line">        C c = new C(); </span><br><span class="line">        //ab的show方法先进去，找到参数为A obj，然后再看子类有没有重写 ，重写就执行子类的show</span><br><span class="line">        System.out.println(ab.show(b));   </span><br><span class="line">        System.out.println(ab.show(c)); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">运行代码结果如下： </span><br><span class="line">B and A </span><br><span class="line">B and A</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">例子：动态+初始化编译</span><br><span class="line"></span><br><span class="line">class Father&#123;</span><br><span class="line">	int age = 40;</span><br><span class="line">	Father()&#123;</span><br><span class="line">		show();</span><br><span class="line">	&#125;</span><br><span class="line">	public void show () &#123;</span><br><span class="line">		System.out.println(age);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Son extends Father &#123;</span><br><span class="line">	int age = 20;</span><br><span class="line">	public void show() &#123;</span><br><span class="line">		System.out.println(age);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Demo &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Father f = new Son();</span><br><span class="line">		f.show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//0 20</span><br><span class="line">//先执行构造函数，父类构造函数执行show的时候</span><br><span class="line">//父类的Age还没有初始化，默认为0，</span><br><span class="line">//f.show的时候，先执行父类，但是子类重写过，所有就执行子类的show方法</span><br><span class="line"></span><br><span class="line">public class Demo &#123; </span><br><span class="line">    class Super&#123;  </span><br><span class="line">        int flag=1;</span><br><span class="line">         Super()&#123;</span><br><span class="line">             test();</span><br><span class="line">         &#125;  void test()&#123;</span><br><span class="line">            System.out.println(&quot;Super.test() flag=&quot;+flag);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    class Sub extends Super&#123;</span><br><span class="line">        Sub(int i)&#123;  </span><br><span class="line">            flag=i;</span><br><span class="line">            System.out.println(&quot;Sub.Sub()flag=&quot;+flag);</span><br><span class="line">        &#125;  void test()&#123;</span><br><span class="line">            System.out.println(&quot;Sub.test()flag=&quot;+flag);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        new Demo().new Sub(5);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">    // Sub.Sub()flag= 1 Sub.Sub()flag= 5</span><br><span class="line">    //这个比上面那个区别是：这个子类没有申明flag，直接用父类的，上面的从新申明了</span><br></pre></td></tr></table></figure>

<h2 id="4、单分派与多分派"><a href="#4、单分派与多分派" class="headerlink" title="4、单分派与多分派"></a>4、单分派与多分派</h2><ul>
<li><p><em>方法的接收者、方法的参数都可以称为方法的宗量</em>。根据分批基于多少种宗量，可以将分派划分为单分派和多分派。单分派是根据一个宗量对目标方法进行选择的，多分派是根据多于一个的宗量对目标方法进行选择的。</p>
</li>
<li><p>Java在进行静态分派时，选择目标方法要依据两点：一是变量的静态类型是哪个类型，二是方法参数是什么类型。因为要根据两个宗量进行选择，所以Java语言的静态分派属于多分派类型。</p>
</li>
<li><p>运行时阶段的动态分派过程，由于编译器已经确定了目标方法的签名（包括方法参数），运行时虚拟机只需要确定方法的接收者的实际类型，就可以分派。因为是根据一个宗量作为选择依据，所以Java语言的动态分派属于单分派类型。</p>
</li>
</ul>
<h2 id="5、虚拟机动态分派的实现"><a href="#5、虚拟机动态分派的实现" class="headerlink" title="5、虚拟机动态分派的实现"></a>5、虚拟机动态分派的实现</h2><ul>
<li><p>由于动态分派是非常频繁的动作，而动态分派在方法版本选择过程中又需要在方法元数据中搜索合适的目标方法，虚拟机实现出于性能的考虑，通常不直接进行如此频繁的搜索，而是采用优化方法。</p>
</li>
<li><p>其中一种“稳定优化”手段是：在类的方法区中建立一个虚方法表（Virtual Method Table, 也称vtable, 与此对应，也存在接口方法表——Interface Method Table，也称itable）。使用虚方法表索引来代替元数据查找以提高性能。其原理与C++的虚函数表类似。</p>
</li>
<li><p>通过虚方法表存放各个方法的实际入口地址，如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口；如果子类中重写了这个方法，子类方法表中的地址将会诶替换为指向子类实现版本的入口地址。</p>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/10/看书笔记/深入理解Java虚拟机/8、类加载器与双亲委派模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wfc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="只想当扫地机器人的老王">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/10/看书笔记/深入理解Java虚拟机/8、类加载器与双亲委派模型/" class="post-title-link" itemprop="url">8、类加载器与双亲委派模型</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-10 07:57:02" itemprop="dateCreated datePublished" datetime="2019-07-10T07:57:02+08:00">2019-07-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-08 19:33:04" itemprop="dateModified" datetime="2019-07-08T19:33:04+08:00">2019-07-08</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/看书笔记/" itemprop="url" rel="index"><span itemprop="name">看书笔记</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/看书笔记/深入理解Java虚拟机/" itemprop="url" rel="index"><span itemprop="name">深入理解Java虚拟机</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="显示加载"><a href="#显示加载" class="headerlink" title="显示加载"></a>显示加载</h2><ul>
<li>当 JVM 执行第一行代码“ Student s = new Student();”时</li>
<li>JVM 先碰到了 Student 类，“ Student s = new Student();”</li>
<li>此时，JVM 将查看方法区中是否有 Student 对应的 Class 对象（我们学习过反射，都知道 Class 对象，在同一个 JVM 中，可以有很多的 Student 实例，但是 Student 的 Class 对象只有一个）。</li>
<li>如果加载过了，那么直接返回</li>
<li>因为是第一次执行，方法区中没有 Student 的 Class 对象，此时 JVM 就会调用类加载器（ClassLoader）。</li>
<li>ClassLoader会使用父类加载器，父类加载器如果加载过了直接返回，没有就调用父类的父类。直到没有父类加载器，他会判断自己无法完成该加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会自己去加载。</li>
</ul>
<h3 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h3><ol>
<li>实现类加载的功能</li>
<li>确定被加载类在Java虚拟机中的唯一性</li>
</ol>
<h4 id="1-1-实现类加载的功能"><a href="#1-1-实现类加载的功能" class="headerlink" title="1.1 实现类加载的功能"></a>1.1 实现类加载的功能</h4><p>即实现类加载过程中“加载”环节里“通过类的全限定名来获取定义此类的二进制字节流”的功能（类加载5个阶段）</p>
<h4 id="1-2-确立被加载类在Java虚拟机中的唯一性"><a href="#1-2-确立被加载类在Java虚拟机中的唯一性" class="headerlink" title="1.2 确立被加载类在Java虚拟机中的唯一性"></a>1.2 确立被加载类在Java虚拟机中的唯一性</h4><ul>
<li>确定两个类是否相等的依据：<strong>是否由同一个类加载器加载</strong></li>
</ul>
<ol>
<li>若由同一个类加载器加载，则这两个类相等； 若由不同的类加载器加载，则这两个类不相等。</li>
<li>即使两个类来源于同一个 Class 文件、被同一个虚拟机加载，这两个类都不相等</li>
</ol>
<ul>
<li>在实际使用中，是通过下面方法的返回结果（Boolean值）进行判断：</li>
</ul>
<ol>
<li>Class对象的equals()方法</li>
<li>Class对象的isAssignableFrom()方法</li>
<li>Class对象的isInstance()方法</li>
</ol>
<ul>
<li>当然也会使用instanceof关键字做对象所属关系判定等情况</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">/例子</span><br><span class="line">public class Test &#123; </span><br><span class="line"></span><br><span class="line">    // 自定义一个类加载器：myLoader</span><br><span class="line">    // 作用：可加载与自己在同一路径下的Class文件</span><br><span class="line">    static ClassLoader myLoader = new ClassLoader() &#123; </span><br><span class="line">        @Override </span><br><span class="line">        public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123; </span><br><span class="line"> </span><br><span class="line">            if (!name.equals(&quot;com.carson.Test&quot;)) </span><br><span class="line">                return super.loadClass(name); </span><br><span class="line"> </span><br><span class="line">            try &#123; </span><br><span class="line">                String fileName = name.substring(name.lastIndexOf(&quot;.&quot;) + 1) </span><br><span class="line">                        + &quot;.class&quot;; </span><br><span class="line"> </span><br><span class="line">                InputStream is = getClass().getResourceAsStream(fileName); </span><br><span class="line">                if (is == null) &#123; </span><br><span class="line">                    return super.loadClass(fileName); </span><br><span class="line">                &#125; </span><br><span class="line">                byte[] b = new byte[is.available()]; </span><br><span class="line">                is.read(b); </span><br><span class="line">                return defineClass(name, b, 0, b.length); </span><br><span class="line"> </span><br><span class="line">            &#125; catch (IOException e) &#123; </span><br><span class="line">                throw new ClassNotFoundException(name); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;; </span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) throws Exception &#123; </span><br><span class="line"> </span><br><span class="line">        Object obj = myLoader.loadClass(&quot;com.carson.Test&quot;); </span><br><span class="line">        // 1. 使用该自定义类加载器加载一个名为com.carson.Test的类</span><br><span class="line">        // 2. 实例化该对象</span><br><span class="line"></span><br><span class="line">        System.out.println(obj); </span><br><span class="line">        // 输出该对象的类 -&gt;&gt;第一行结果分析</span><br><span class="line"></span><br><span class="line">        System.out.println(obj instanceof com.carson.Test); </span><br><span class="line">        // 判断该对象是否属于com.carson.Test类 -&gt;&gt;第二行结果分析</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;-- 输出结果 --&gt;</span><br><span class="line">class com.carson.Test </span><br><span class="line">false</span><br><span class="line"></span><br><span class="line">// 第一行结果分析</span><br><span class="line">// obj对象确实是com.carson.Test类实例化出来的对象</span><br><span class="line"></span><br><span class="line">// 第二行结果分析</span><br><span class="line">// obj对象与类com.huachao.Test做所属类型检查时却返回了false</span><br><span class="line">// 原因：虚拟机中存在了两个Test类（1 &amp; 2）：1是由系统应用程序类加载器加载的，2是由我们自定义的类加载器加载</span><br><span class="line">// 虽然都是来自同一个class文件，但由于由不同类加载器加载，所以依然是两个独立的类</span><br><span class="line">// 做对象所属类型检查结果自然为false。</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B1.jpg" alt></p>
<p>重点为：</p>
<ol>
<li>启动类加载器</li>
<li>扩展类加载器</li>
<li>应用程序类加载器</li>
</ol>
<h4 id="2-1启动类加载器（Bootstrap-ClassLoader）"><a href="#2-1启动类加载器（Bootstrap-ClassLoader）" class="headerlink" title="2.1启动类加载器（Bootstrap ClassLoader）"></a>2.1启动类加载器（Bootstrap ClassLoader）</h4><ul>
<li>作用：负责加载以下类</li>
</ul>
<ol>
<li>存放在 &lt; JAVA_HOME &gt; \ lib中目录中的类</li>
<li>被-Xbootclasspath参数所指定路径中，并且是被虚拟机识别的类库</li>
</ol>
<p>仅按文件名识别，如：rt.jar中，名字不符合的类库即使放在LIB目录中也不会被加载</p>
<ul>
<li>特别注意</li>
</ul>
<ol>
<li>启动类加载器无法被Java程序直接引用</li>
<li>用户在编写自定义类加载器时，若需把加载请求委派给引导类加载器，直接使用null代替即可，如java.lang.ClassLoader.getClassLoader（）方法所示：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@CallerSensitive </span><br><span class="line">public ClassLoader getClassLoader() &#123; </span><br><span class="line">    ClassLoader cl = getClassLoader0(); </span><br><span class="line">    if (cl == null) </span><br><span class="line">        return null; </span><br><span class="line">    SecurityManager sm = System.getSecurityManager(); </span><br><span class="line">    if (sm != null) &#123; </span><br><span class="line">        ClassLoader.checkClassLoaderPermission(cl, Reflection.getCallerClass()); </span><br><span class="line">    &#125; </span><br><span class="line">    return cl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2扩展类加载器（Extension-ClassLoader）"><a href="#2-2扩展类加载器（Extension-ClassLoader）" class="headerlink" title="2.2扩展类加载器（Extension ClassLoader）"></a>2.2扩展类加载器（Extension ClassLoader）</h4><ul>
<li>作用：负责加载以下类：</li>
</ul>
<ol>
<li>&lt; JAVA_HOME &gt; \ lib中\分机目录中的类库</li>
<li>被java.ext.dirs系统变量所指定的路径中的所有类库</li>
</ol>
<ul>
<li>特别注意</li>
</ul>
<ol>
<li>由sum.misc.Launcher $的ExtClassLoader类实现</li>
<li>开发者可以直接使用扩展类加载器</li>
</ol>
<h4 id="2-3应用程序类加载器（Application-ClassLoader）"><a href="#2-3应用程序类加载器（Application-ClassLoader）" class="headerlink" title="2.3应用程序类加载器（Application ClassLoader）"></a>2.3应用程序类加载器（Application ClassLoader）</h4><ul>
<li>作用：</li>
</ul>
<p>负责加载用户类路径（ClassPath）上所指定的类库</p>
<ul>
<li>特别注意</li>
</ul>
<ol>
<li>也称为系统类加载器，因为该类加载器是类加载器中的getSystemClassLoader（）方法的返回值</li>
<li>由sum.misc.Launcher $ AppClassLoader类实现</li>
<li>开发者可以直接使用该类加载器</li>
<li>若开发者没自定义类加载器，程序默认使用该类加载器</li>
</ol>
<p>各种类加载器的使用并不是孤立的，而是相互配合使用</p>
<p>在Java虚拟机中，各种类加载器配合使用的模型（关系）是<strong>双亲委派模型</strong></p>
<h3 id="3-双亲委派模型"><a href="#3-双亲委派模型" class="headerlink" title="3.双亲委派模型"></a>3.双亲委派模型</h3><p>作用：</p>
<ul>
<li>因为这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要子类加载器再加载一次。避免同样多份字节码加载</li>
<li>安全</li>
<li>采用双亲委派的一个好处是比如加载位于rt.jar的包中的类java.lang.Object中，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个目标对象。</li>
</ul>
<p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。因此，使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处：类随着它的类加载器一起具备了一种带有优先级的层次关系。</p>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B2.jpg" alt></p>
<p>双亲委派模型的工作流程代码实现在 java.lang.ClassLoader中的的loadClass()中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//具体如下</span><br><span class="line">@Override </span><br><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve) </span><br><span class="line">        throws ClassNotFoundException &#123; </span><br><span class="line">    Class&lt;?&gt; c = findLoadedClass(name); </span><br><span class="line"></span><br><span class="line">  // 检查需要加载的类是否已经被加载过</span><br><span class="line">    if (c == null) &#123; </span><br><span class="line">        try &#123; </span><br><span class="line">             // 若没有加载，则调用父加载器的loadClass()方法</span><br><span class="line">            if (parent != null) &#123; </span><br><span class="line">                c = parent.loadClass(name, false); </span><br><span class="line">            &#125;else&#123; </span><br><span class="line">                // 若父类加载器为空，则默认使用启动类加载器作为父加载器</span><br><span class="line">                c=findBootstrapClassOrNull(name); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123; </span><br><span class="line">            // 若父类加载器加载失败会抛出ClassNotFoundException， </span><br><span class="line">            //说明父类加载器无法完成加载请求 </span><br><span class="line">        &#125; </span><br><span class="line">        if(c==null)&#123; </span><br><span class="line">            // 在父类加载器无法加载时 </span><br><span class="line">            // 再调用本身的findClass方法进行类加载 </span><br><span class="line">            c=findClass(name); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    if(resolve)&#123; </span><br><span class="line">        resolveClass(c); </span><br><span class="line">    &#125; </span><br><span class="line">    return c; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>各个类加载器之间是组合关系，并非继承关系。</strong></p>
<p>步骤总结：若一个类加载器收到了类加载请求</p>
<ol>
<li><p>该类把加载请求委派给父类加载器去完成，而不会自己去加载该类：每层的类加载器都是如此，因此所有的加载请求最终都应传送到顶层的启动类加载器中</p>
</li>
<li><p>只有当父类加载器反馈自己无法完成该加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会自己去加载</p>
</li>
</ol>
<p>以自定义STRIG类为例子</p>
<p>加载某个类时，优先使用父类加载器加载需要使用的类。如果我们自定义了java.lang.String这个类，加载该自定义的字符串类，该自定义字符串类使用的加载器是AppClassLoader ExtClassLoader，所有这些加载字符串使用的类加载器是ExtClassLoader，但是类加载器ExtClassLoader在jre / lib / ext目录下没有找到String.class类。然后使用ExtClassLoader父类的加载器BootStrap，父类加载器BootStrap在JRE / lib目录的rt.jar找到了String.class，将其加载到内存中。这就是类加载器的委托机制。</p>
<p>优点<br>Java的类随着它的类加载器一起具备了一种带优先级的层次关系</p>
<p>如：类java.lang.Object（存放在rt.jar中）在加载过程中，无论哪一个类加载器要加载这个类，最终需委派给模型顶端的启动类加载器进行加载，因此对象类在程序的各种类加载器环境中都是同一个类。</p>
<p>若没有使用双亲委派模型（即由各个类加载器自行去加载），用户编写了一个java.lang.Object继承的类（放在类路径中），那系统中将出现多个不同的对象类，Java的体系中最基础的行为就无法保证。</p>
<h3 id="4-自定义类加载器"><a href="#4-自定义类加载器" class="headerlink" title="4.自定义类加载器"></a>4.自定义类加载器</h3><p>以下代码中的FileSystemClassLoader是自定义类加载器，继承自java.lang.ClassLoader，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（.class文件），然后读取该文件内容，最后通过defineClass（）方法来把这些字节代码转换成java.lang.Class类的实例。</p>
<p>java.lang.ClassLoader的loadClass（）实现了双亲委派模型的逻辑，自定义类加载器一般不去重写它，但是需要重写findClass（）方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class FileSystemClassLoader extends ClassLoader &#123;</span><br><span class="line"></span><br><span class="line">    private String rootDir;</span><br><span class="line"></span><br><span class="line">    public FileSystemClassLoader(String rootDir) &#123;</span><br><span class="line">        this.rootDir = rootDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        byte[] classData = getClassData(name);</span><br><span class="line">        if (classData == null) &#123;</span><br><span class="line">            throw new ClassNotFoundException();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return defineClass(name, classData, 0, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private byte[] getClassData(String className) &#123;</span><br><span class="line">        String path = classNameToPath(className);</span><br><span class="line">        try &#123;</span><br><span class="line">            InputStream ins = new FileInputStream(path);</span><br><span class="line">            ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">            int bufferSize = 4096;</span><br><span class="line">            byte[] buffer = new byte[bufferSize];</span><br><span class="line">            int bytesNumRead;</span><br><span class="line">            while ((bytesNumRead = ins.read(buffer)) != -1) &#123;</span><br><span class="line">                baos.write(buffer, 0, bytesNumRead);</span><br><span class="line">            &#125;</span><br><span class="line">            return baos.toByteArray();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String classNameToPath(String className) &#123;</span><br><span class="line">        return rootDir + File.separatorChar</span><br><span class="line">                + className.replace(&apos;.&apos;, File.separatorChar) + &quot;.class&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//主要是通过继承自ClassLoader类 从而自定义一个类加载器 MyClassLoader.java</span><br><span class="line">// 继承自ClassLoader类</span><br><span class="line">public class MyClassLoader extends ClassLoader &#123; </span><br><span class="line">    // 类加载器的名称 </span><br><span class="line">    private String name; </span><br><span class="line">    // 类存放的路径 </span><br><span class="line">    private String classpath = &quot;E:/&quot;; </span><br><span class="line"> </span><br><span class="line">    MyClassLoader(String name) &#123; </span><br><span class="line">        this.name = name; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    MyClassLoader(ClassLoader parent, String name) &#123; </span><br><span class="line">        super(parent); </span><br><span class="line">        this.name = name; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    @Override </span><br><span class="line">    public Class&lt;?&gt; findClass(String name) &#123;  </span><br><span class="line">        byte[] data = loadClassData(name); </span><br><span class="line">        return this.defineClass(name, data, 0, data.length); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    public byte[] loadClassData(String name) &#123; </span><br><span class="line">        try &#123; </span><br><span class="line">            name = name.replace(&quot;.&quot;, &quot;//&quot;); </span><br><span class="line">            System.out.println(name); </span><br><span class="line">            FileInputStream is = new FileInputStream(new File(classpath + name </span><br><span class="line">                    + &quot;.class&quot;)); </span><br><span class="line">            byte[] data = new byte[is.available()]; </span><br><span class="line">            is.read(data); </span><br><span class="line">            is.close(); </span><br><span class="line">            return data; </span><br><span class="line"> </span><br><span class="line">        &#125; catch (Exception e) &#123; </span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">        &#125; </span><br><span class="line">        return null; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如我们的类不在类路径下，而我们又想读取一个自定义的目录下的类，如果做呢？<br>//示例读取c:/test/com/test.jdk/Key.class这个类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package com.test.jdk;</span><br><span class="line"></span><br><span class="line">public class Key &#123;</span><br><span class="line">    private String key = &quot;111111&quot;;</span><br><span class="line">&#125;</span><br><span class="line">import org.apache.commons.io.IOUtils;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line"></span><br><span class="line">public class LocalClassLoader extends ClassLoader &#123;</span><br><span class="line"></span><br><span class="line">    private String path = &quot;c:/test/&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; cls = findLoadedClass(name);</span><br><span class="line">        if (cls != null) &#123;</span><br><span class="line">            return cls;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!name.endsWith(&quot;.Key&quot;)) &#123;</span><br><span class="line">            return super.loadClass(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            InputStream is = new FileInputStream(path + name.replace(&quot;.&quot;, &quot;/&quot;) + &quot;.class&quot;);</span><br><span class="line">            byte[] bytes = IOUtils.toByteArray(is);</span><br><span class="line">            return defineClass(name, bytes, 0, bytes.length);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return super.loadClass(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//自定义类加载器正常加载到类，程序最后输出：111111</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        LocalClassLoader lcl = new LocalClassLoader();</span><br><span class="line">        Class&lt;?&gt; cls = lcl.loadClass(&quot;com.test.jdk.Key&quot;);</span><br><span class="line">        Field field = FieldUtils.getField(cls, &quot;key&quot;, true);</span><br><span class="line">        Object value = field.get(cls.newInstance());</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>URLClassLoader上面自定义一个类加载器来读取自定义的目录，其实可以直接使用URLClassLoader就能读取，它已经实现了路径下类的读取逻辑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        URLClassLoader ucl = new URLClassLoader(new URL[]&#123;new URL(&quot;c:/test/&quot;)&#125;);</span><br><span class="line">        Class&lt;?&gt; cls = ucl.loadClass(&quot;com.test.jdk.Key&quot;);</span><br><span class="line">        Field field = FieldUtils.getField(cls, &quot;key&quot;, true);</span><br><span class="line">        Object value = field.get(cls.newInstance());</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-破坏双亲委派模型"><a href="#5-破坏双亲委派模型" class="headerlink" title="5.破坏双亲委派模型"></a>5.破坏双亲委派模型</h3><p>双亲委派模型并不是一个强制性的约束模型。</p>
<p>双亲委派模型主要出现过3次较大规模“被破坏”的情况。</p>
<ol>
<li><p>第一次破坏是因为类加载器和抽象类java.lang.ClassLoader中在JDK1.0就存在的，而双亲委派模型在JDK1.2之后才被引入，为了兼容已经存在的用户自定义类加载器，引入双亲委派模型时做了一定的妥协：在java.lang.ClassLoader中中引入了一个的findClass（）方法，在此之前，用户去继承java.lang.ClassLoader中的唯一目的就是重写的loadClass（）方法.JDK1 0.2之后不提倡用户去覆盖的loadClass（）方法，而是把自己的类加载逻辑写到的findClass（）方法中，如果的loadClass（）方法中如果父类加载失败，则会调用自己的的findClass（）方法来完成加载，这样就可以保证新写出来的类加载器是符合双亲委派模型规则的。</p>
</li>
<li><p>第二次破坏是因为模型自身的缺陷，现实中存在这样的场景：基础的类加载器需要求调用用户的代码，而基础的类加载器可能不认识用户的代码为此，Java的设计团队引入的设计时“线程上下文类加载器（Thread Context ClassLoader）”。这样可以通过父类加载器请求子类加载器去完成类加载动作。已经违背了双亲委派模型的一般性原则。</p>
</li>
<li><p>第三次破坏是由于用户对程序动态性的追求导致的。这里所述的动态性是指：“代码热替换”，“模块热部署”等等比较热门的词。说白了就是希望应用程序能够像我们的计算机外设一样，接上鼠标，U盘不用重启机器就能立即使用.OSGi是当前业界“事实上”的Java的模块化标准，OSGi的实现模块化热部署的关键是它自定义的类加载器机制的实现。每一个程序模块（OSGi的中称为包）都有一个自己的类加载器，当需要更换一个包时，就把束连同类加载器一起换掉以实现代码的热替换。在OSGi环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构。当收到类加载请求时，osgi将按照下面的顺序进行类搜索：</p>
</li>
</ol>
<ul>
<li>1）将以java。*开头的类委派给父类加载器加载</li>
<li>2）否则，将委员列表名单（配置文件org.osgi.framework.bootdelegation中定义）内的类委派给父类加载器加载</li>
<li>3）否则，检查是否在Import-Package中声明，如果是，则委派给出口这个类的Bundle的类加载器加载</li>
<li>4）否则，检查是否在Require-Bundle中声明，如果是，则将类加载请求委托给必需的捆绑的类加载器</li>
<li>5）否则，查找当前Bundle的ClassPath，使用自己的类加载器加载</li>
<li>6）否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载</li>
<li>7）否则，查找Dynamic Import-Package（动态导入只有在真正用到此包的时候才进行加载）的Bundle，委派给对应Bundle的类加载器加载</li>
<li>8）否则，类查找失败</li>
</ul>
<h2 id="隐式加载"><a href="#隐式加载" class="headerlink" title="隐式加载"></a>隐式加载</h2><p>他们都能在运行时对任意一个类，都能够知道该类的所有属性和方法;对于任意一个对象，都能够调用它的任意方法和属性。</p>
<ul>
<li>的loadClass</li>
</ul>
<p>加载</p>
<p>链接（校验准备解析）</p>
<p>初始化</p>
<p>Classloder.loaderClass得到的类是还没有链接的</p>
<ul>
<li>的forName</li>
</ul>
<p>的Class.forName得到的类是已经初始化完成的</p>
<p>调用的时候静代码块直接运行</p>
<p>这样我们需要初始化后才能得到的DriverManager，所以我们选择使用的Class.forName()</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/10/看书笔记/深入理解Java虚拟机/7、类加载的5个过程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wfc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="只想当扫地机器人的老王">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/10/看书笔记/深入理解Java虚拟机/7、类加载的5个过程/" class="post-title-link" itemprop="url">7、类加载的5个过程</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-10 07:57:02" itemprop="dateCreated datePublished" datetime="2019-07-10T07:57:02+08:00">2019-07-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-05 11:38:29" itemprop="dateModified" datetime="2019-07-05T11:38:29+08:00">2019-07-05</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/看书笔记/" itemprop="url" rel="index"><span itemprop="name">看书笔记</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/看书笔记/深入理解Java虚拟机/" itemprop="url" rel="index"><span itemprop="name">深入理解Java虚拟机</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1、类加载的本质"><a href="#1、类加载的本质" class="headerlink" title="1、类加载的本质"></a>1、类加载的本质</h2><p>将描述类的数据从Class文件加载到内存&amp;对数据进行校验、转换解 和初始化，最终形成可被虚拟机直接使用的Java使用类型：<strong>Class文件是一串二进制字节流</strong>。</p>
<h2 id="2、类加载过程"><a href="#2、类加载过程" class="headerlink" title="2、类加载过程"></a>2、类加载过程</h2><p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B11.png" alt></p>
<p>分为七个步骤，其中五个关键步骤：加载 -&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化</p>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B2.jpg" alt></p>
<p>这几个阶段中的：加载、验证、准备、初始化、卸载的顺序是固定的。但是解析则有可能在初始化之后才开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。</p>
<p>注意：上文所说按部就班地“开始”，而不是“进行”或“完成”，强调这点是因为这些阶段通常都是互相交叉地混合式进行，通常会在一个阶段执行的过程中调用、激活另一个阶段。加载阶段 与 连接阶段 的部分内容（如一部分字节码文件格式验证动作）是交叉进行的。加载阶段尚未完成，连接阶段可能已经开始，但这些加载加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。</p>
<ul>
<li>虚拟机对于类的初始化阶段严格规定了有且仅有只有5种情况如果对类没有进行过初始化，则必须对类进行“初始化”！</li>
</ul>
<ol>
<li><p>遇到new、读取一个类的静态字段（getstatic）、设置一个类的静态字段（putstatic）、调用一个类的静态方法（invokestatic）。类没有初始化，那么需要先触发进行初始化。</p>
</li>
<li><p>使用java.lang.reflect包的方法对类进行反射调用时。</p>
</li>
<li><p>当类初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。（如果是接口，则不必触发其父类初始化）</p>
</li>
<li><p>当虚拟机执行一个main方法时，会首先初始化main所在的这个主类。</p>
</li>
<li><p>当只用jdk1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。（暂未研究此种场景）</p>
</li>
</ol>
<ul>
<li>不会被初始化的三种情况：</li>
</ul>
<ol>
<li>对于静态字段，只有直接定义这个字段的类才会被初始化，通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</li>
<li>所有引用类的方式都不会触发初始化称为被动引用。比如数组 A[] a = new A[];</li>
<li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接饮用到定义常量的类。进一步解释，虽然在main方法中引用了ConstClass类中的常量HELLO，但其实在编译阶段通过常量传播优化，已经将此常量的值“hello”存储到了Main类的常量池中，之后对ConstClass.HELLO的引用实际上都被转化为Main类对自身常量池的引用。也就是说，两个类在编译过后实际上不存在任何联系了。</li>
</ol>
<h3 id="步骤1：加载（加载到方法区）"><a href="#步骤1：加载（加载到方法区）" class="headerlink" title="步骤1：加载（加载到方法区）"></a>步骤1：加载（加载到方法区）</h3><p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B3.jpg" alt></p>
<p>加载，将外部的类文件加载到虚拟机或者存储到方法区内是指查找字节流，并且据此创建类的过程。前面提到，对于数组类来说，它并没有对应的字节流，而是由Java虚拟机直接生成的。对于其他的类来说，Java虚拟机则需要借助类加载器来完成查找字节流的过程。类加载器实现的功能是即为加载阶段获取二进制字节流的时候。</p>
<ul>
<li>虚拟机完成三件事情：</li>
</ul>
<ol>
<li><p>通过一个类的全限定名来获取此类的二进制字节流；<br>注意：这里的二进制字节流并不只是单纯地从Class文件中获取，比如它还可以从Jar包中获取、从网络中获取（最典型的应用便是Applet）、由其他文件生成（JSP应用）等。</p>
</li>
<li><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；<br>注：“方法区域Java堆一样，是各线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据”。而方法区中的数据存储结构格式虚拟机自行定义。</p>
</li>
<li><p>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。<br>注：加载阶段完成后，虚拟机在内存中实例化一个java.lang.Class类的对象（Class是一个实实在在的对象，是记录着类成员、接口等信息的对象）。还有一点是，我们都知道对象肯定是存放在堆中的，但Class对象比较特殊，对于HotSpot虚拟机而言，Class对象是存放在方法区中的。</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B4.jpg" alt></p>
<ul>
<li>对于非数组类</li>
</ul>
<p>非数组类加载过程是开发人员可控性最强的，可以使用系统提供的引导类加载器，也可以由用户自定义类加载器完成（重新一个类加载器 loadClass()）。 对于数组类而言，数组类本身不通过类加载器创建，它是由Java虚拟机直接创建的，但是数组类的元素类型（Element Type，是指数组去掉所有维度的类型）最终要靠类加载器去创建，一个数组类（简称为C）创建过程要遵循以下规则：</p>
<ol>
<li>如果数组的组件类型是引用类型（非基础类型），那就递归去加载这个组件类型数组类将在加载该组件类型的类加载器的类名称空间上被标识。</li>
<li>如果数组组件类型不是引用类型（例如int[]数组），Java虚拟机将会把该数组标记为与引导类加载器关联。</li>
<li>数组类的可见性与他的组件类型可见性一致，如果组件类型不是引用类型，那数组的可见性将默认为public。</li>
</ol>
<p>加载阶段完成后，<em>虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区的数据存储格式由虚拟机实现自行定义，虚拟机规范未规定此区域的具体数据结构</em>。然后在内存实例化一个 java.lang.Class类的对象（并无明确规定是在Java 堆中，对于HotSpot虚拟机而言，Class对象比较特殊，它虽是对象，但存放在方法区里），这个对象将作为程序访问方法区中的这些类型数据的外部接口。</p>
<h3 id="步骤2：验证"><a href="#步骤2：验证" class="headerlink" title="步骤2：验证"></a>步骤2：验证</h3><p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B5.jpg" alt></p>
<p>验证是连接阶段的第一步，<strong>目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</strong>。验证阶段非常重要，直接决定了虚拟机是否能承受恶意代码的攻击，从执行性能的角度来讲，该阶段的工作量在虚拟机的类加载子系统中占有了相当大一部分。</p>
<p>Java语言本身是相对安全的语言（相对于C/C++），使用纯粹的Java代码无法做到诸如访问数组边界之外的数据、将一个对象转型为它未实现的数据类型、跳转到不存在的代码行等，如果这样做了，编译器将拒绝编译，但是Class文件不一定由Java源码编译而来，完全可以使用任何途径，如：用十六进制编辑器直接编写来产生Class文件，在字节码层面上，上述Java代码无法做到的事情都是可以实现的，此时虚拟机如果不检查输入的字节流，很有可能因为载入了有害的字节流而导致系统崩溃，所以验证时虚拟机对自身保护的一项重要工作。</p>
<p>验证阶段是非常重要的，但不是一定必要的阶段（对程序运行期没有影响），如果运行的全部代码都被反复使用和验证过，那么在实施阶段可以考虑通过参数-Xverify:none 来关闭类验证措施，以缩短虚拟机类加载的时间。</p>
<p>大致都会完成以下四个阶段的验证：</p>
<ol>
<li>文件格式的验证</li>
<li>元数据的验证</li>
<li>字节码验证</li>
<li>符号引用验证</li>
</ol>
<h3 id="步骤3：准备"><a href="#步骤3：准备" class="headerlink" title="步骤3：准备"></a>步骤3：准备</h3><p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B6.jpg" alt></p>
<ul>
<li>正式为<strong>类变量（静态变量）分配内存并设置变量初始值</strong>的阶段这些变量所使用的内存都在方法区中进行分配，对静态字段的具体初始化，则会在稍后的初始化阶段中进行。</li>
<li>除了分配内存外，部分 Java 虚拟机还会在此阶段构造其他跟类层次相关的数据结构，比如说用来实现虚方法的动态绑定的方法表。</li>
<li>在 class 文件被加载至 Java 虚拟机之前，这个类无法知道其他类及其方法、字段所对应的具体地址，甚至不知道自己方法、字段的地址。因此，每当需要引用这些成员时，Java编译器会生成一个符号引用。在运行阶段，这个符号引用一般都能够无歧义地定位到具体目标上。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B7.jpg" alt></p>
<p>此阶段有2个容易混淆的部分需要特别强调：</p>
<p>该阶段进行内存分配的<strong>仅包括类变量（被static修饰的变量），不包括实例变量</strong>，实例变量将在对象初始化时随对象一起分配在堆内存中 这里所说的初始值“通常情况下”是指数据类型的零值 假设一个类变量的定义为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static int value = 123；</span><br></pre></td></tr></table></figure>

<p>那变量value在准备阶段过后的初始化值为0而不是123，因为这是尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后存放在类构造器()方法之中，所以把value赋值为123的动作将在初始化阶段才会执行。</p>
<p>上面提到的在“通常情况”下初始值为零值，但还是会有一些特殊情况，如下：</p>
<p>类字段的字段属性表中存在ConstantValue属性（只有同时被final和static修饰的字段才有ConstantValue属性），那在准备阶段变量value就会被初始化微ConstantValue属性所指定的值。编译时Javac将会为vaue生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final static int value = 123；</span><br></pre></td></tr></table></figure>

<h3 id="步骤4：解析"><a href="#步骤4：解析" class="headerlink" title="步骤4：解析"></a>步骤4：解析</h3><p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B6.jpg" alt></p>
<p><strong>解析阶段是虚拟机将常量池中的符号引用替换为直接引用的过程</strong></p>
<ul>
<li><p>符号引用 （Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。 符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须一致，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。</p>
</li>
<li><p>直接引用（Direct Refenrences）：直接引用可以是直接目标的指针、相对偏移量或是一个能间接定位到目标的句柄。 直接引用是和虚拟机实现的内存布局有关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那么引用的目标必定已经在内存中存在</p>
</li>
</ul>
<hr>
<p>对同一个符号引用进行多次解析请求是很常见的事情，虚拟机实现可以对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标识为已解析状态）从而避免解析动作重复进行。但对于invokedynamic指令，上面规则则不成立。当碰到某个前面已经由invokedynamic指令触发过解析的符号引用时，并不意味着这个解析结果对其他invokedynamic指令也同样生效。因为invokedynamic指令是JDK1.7新加入的指令，目的用于动态语言支持，它所对应的引用称为“动态调用点限定符”（Dynamic Call Site Specifier），这里“动态”的含义就是必须等到程序实际运行到这条指令的时候，解析动作才能进行。相对的，其余可触发解析的指令都是“静态”的，可以在刚刚完成加载阶段，还没有执行代码时就进行解析。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号进行引用，下面只对前4种引用的解析过程进行介绍，对于后面3种与JDK1.7新增的动态语言支持息息相关。</p>
<ol>
<li>类或接口解析：假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，那虚拟机完成这个解析的过程需要以下3个步骤</li>
</ol>
<ul>
<li>C不是一个数组类型，虚拟机会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，由于元数据验证、字节码验证的需要，有可能触发其他相关类的加载动作。</li>
<li>如果C是一个数组类型，并且数组的元素类型为对象，例如N是“[Ljava/lang/Integer”的形式，那将会按照第1点的规则加载数组元素类型，如果N的描述符是前面那样，需要加载的元素类型就是“java.lang,Integer”，接着由虚拟机生一个代表此数组维度和元素的数组对象。</li>
<li>如果上面的步骤没有出现异常，C已经在虚拟机中成为了一个有效的类和接口了，但是解析完成之前还有进行符号引用验证，确保D是否具备对C的访问权限。</li>
</ul>
<ol start="2">
<li>字段解析：要解析字段符号引用，首先要对字段表内字段所属的类或接口的符号引用进行解析，如果解析成功，那这个字段所属的类或接口用C表示，虚拟机规范要求安好如下步骤对C进行后续字段的搜索</li>
</ol>
<ul>
<li>如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束</li>
<li>否则如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束</li>
<li>否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果父类包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束</li>
<li>否则查找失败，抛出异常java.lang.NoSuchMethodError</li>
<li>如果上面的步骤没有出现异常，但是解析完成之前还有进行符号引用验证，确保是否具备对字段的访问权限。</li>
</ul>
<ol start="3">
<li>类方法解析：要解析类方法符号引用，首先要对类方法表中方法所属的类或接口的符号引用进行解析，如果解析成功，那这个方法所属的类或接口用C表示，虚拟机规范要求安好如下步骤对C进行后续类方法的搜索</li>
</ol>
<ul>
<li>类方法和接口房符号引用的常量类型定义是分开的，如果在类方法表中发现class_index中索引的C是个接口，直接抛出java.lang.IncompatibleClassChangeError异常</li>
<li>如果C本身就包含了简单名称和描述符都与目标相匹配的方法，则返回这个方法的直接引用，查找结束</li>
<li>否则，在C的父类中递归查找，如果父类包含了简单名称和描述符都与目标相匹配的方法，则返回这个方法的直接引用，查找结束</li>
<li>在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法， 如果存在匹配的方法，说明类C是一个抽象类，这时查找结束，抛出java.lang,AbstractMethodError异常 这个需要这么理解,如果是普通的类去实现某一个接口的方法的话,那么它肯定在第(2)步已经直接返回.如果能执行到第(4)步,则说明C本身的常量池中并没有对应的直接引用.那么只能是说明这个方法是抽象方法.包含抽象方法的类必定是抽象类,所以这里有个结论就是C是抽象类.</li>
<li>否则查找失败，抛出异常java.lang.NoSuchMethodError</li>
<li>如果上面的步骤没有出现异常，但是解析完成之前还有进行符号引用验证，确保是否具备对方法的访问权限。</li>
</ul>
<ol start="4">
<li>接口方法解析：要解析接口方法符号引用，首先要对接口方法表中方法所属的类或接口的符号引用进行解析，如果解析成功，那这个方法所属接口用C表示，虚拟机规范要求安好如下步骤对C进行后续类方法的搜索</li>
</ol>
<ul>
<li>类方法和接口房符号引用的常量类型定义是分开的，如果在类方法表中发现class_index中索引的C是个类而不是接口，直接抛出java.lang.IncompatibleClassChangeError异常</li>
<li>如果C本身就包含了简单名称和描述符都与目标相匹配的方法，则返回这个方法的直接引用，查找结束</li>
<li>否则，在C的父接口中递归查找，直到找到java.lang.Object类位置。如果包含了简单名称和描述符都与目标相匹配的方法，则返回这个方法的直接引用，查找结束</li>
<li>否则查找失败，抛出异常java.lang.NoSuchMethodError 接口中方法默认都是public的，因此不存在访问权限的事</li>
</ul>
<p><em>符号引用就是一个类中（当然不仅是类，还包括类的其他部分，比如方法，字段等），引入了其他的类，可是JVM并不知道引入的其他类在哪里，所以就用唯一符号来代替，等到类加载器去解析的时候，就把符号引用找到那个引用类的地址，这个地址也就是直接引用。</em></p>
<h2 id="步骤5：初始化"><a href="#步骤5：初始化" class="headerlink" title="步骤5：初始化"></a>步骤5：初始化</h2><p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B9.jpg" alt></p>
<p><strong>将一个类中所有被static关键字标识的代码统一执行一遍，如果执行的是静态变量，那么就会使用用户指定的值覆盖之前在准备阶段设置的初始值；如果执行的是static代码块，那么在初始化阶段，JVM就会执行static代码块中定义的所有操作。</strong></p>
<p>在 Java 代码中，如果要初始化一个静态字段，我们可以在声明时直接赋值，也可以在静态代码块中对其赋值。 如果直接赋值的静态字段被 final 所修饰，并且它的类型是基本类型或字符串时，那么该字段便会被 Java 编译器标记成常量值（ConstantValue），其初始化直接由 Java 虚拟机完成。 除此之外的直接赋值操作，<em>以及所有静态代码块中的代码，则会被 Java 编译器置于同一方法中，并把它命名为 &lt; clinit &gt;</em>。 类加载的最后一步是初始化，便是为标记为常量值的字段赋值，以及执行 &lt; clinit &gt; 方法的过程。Java 虚拟机会通过加锁来确保类的 &lt; clinit &gt; 方法仅被执行一次。</p>
<ul>
<li>()方法是有编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是有语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但不能访问。</li>
<li>()方法与类的构造函数（或者说实例构造器()方法）不同，它不需要显示地调用父类构造器，虚拟机会保证在子类的()方法执行之前，父类的()方法已经执行完毕；</li>
<li>由于父类的()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作；</li>
<li>()方法对于类和接口来说并不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成()方法；</li>
<li>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成()方法。但接口与类不同的是，执行接口的()方法不需要先执行父接口的()方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的()方法。</li>
<li>虚拟机会保证一个类的()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的()方法，其他线程都需要阻塞等待，直到活动线程执行()方法完毕。如果一个类的()方法中有耗时很长的操作，就可能造成多个进程阻塞。</li>
</ul>
<p>那么，类的初始化何时会被触发呢？JVM 规范枚举了下述多种触发情况：</p>
<ol>
<li>当虚拟机启动时，初始化用户指定的主类；</li>
<li>当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类；</li>
<li>当遇到调用静态方法的指令时，初始化该静态方法所在的类；</li>
<li>当遇到访问静态字段的指令时，初始化该静态字段所在的类；</li>
<li>子类的初始化会触发父类的初始化；</li>
<li>如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；</li>
<li>使用反射 API 对某个类进行反射调用时，初始化这个类；</li>
<li>当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。</li>
</ol>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Singleton&#123;</span><br><span class="line">    private static Singleton singleton = new Singleton();</span><br><span class="line">    public static int value1;</span><br><span class="line">    public static int value2 = 0;</span><br><span class="line"></span><br><span class="line">    private Singleton()&#123;</span><br><span class="line">        value1++;</span><br><span class="line">        value2++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Singleton2&#123;</span><br><span class="line">    public static int value1;</span><br><span class="line">    public static int value2 = 0;</span><br><span class="line">    private static Singleton2 singleton2 = new Singleton2();</span><br><span class="line"></span><br><span class="line">    private Singleton2()&#123;</span><br><span class="line">        value1++;</span><br><span class="line">        value2++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton2 getInstance2()&#123;</span><br><span class="line">        return singleton2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Singleton singleton = Singleton.getInstance();</span><br><span class="line">        System.out.println(&quot;Singleton1 value1:&quot; + singleton.value1);</span><br><span class="line">        System.out.println(&quot;Singleton1 value2:&quot; + singleton.value2);</span><br><span class="line"></span><br><span class="line">        Singleton2 singleton2 = Singleton2.getInstance2();</span><br><span class="line">        System.out.println(&quot;Singleton2 value1:&quot; + singleton2.value1);</span><br><span class="line">        System.out.println(&quot;Singleton2 value2:&quot; + singleton2.value2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> //说出运行的结果： </span><br><span class="line">Singleton1 value1 : 1 </span><br><span class="line">Singleton1 value2 : 0 </span><br><span class="line">Singleton2 value1 : 1 </span><br><span class="line">Singleton2 value2 : 1</span><br></pre></td></tr></table></figure>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>Singleton输出结果：1 0<br>原因：</p>
<ol>
<li>首先执行main中的Singleton singleton = Singleton.getInstance(); </li>
<li>类的加载：加载类Singleton </li>
<li>类的验证 </li>
<li>类的准备：为静态变量分配内存，设置默认值。这里为singleton(引用类型)设置为null,value1,value2（基本数据类型）设置默认值0 </li>
<li>类的初始化（按照赋值语句进行修改）： </li>
</ol>
<p>执行private static Singleton singleton = new Singleton(); </p>
<p>先执行Singleton的构造器：</p>
<p>value1++;</p>
<p>value2++; </p>
<p>此时value1，value2均等于1 </p>
<p>再执行 </p>
<p>public static int value1; </p>
<p>public static int value2 = 0; </p>
<p>此时value1=1，value2=0</p>
<p>Singleton2输出结果：1 1 </p>
<p>原因：</p>
<ol>
<li>首先执行main中的Singleton2 singleton2 = Singleton2.getInstance2(); </li>
<li>类的加载：加载类Singleton2 </li>
<li>类的验证 </li>
<li>类的准备：为静态变量分配内存，设置默认值。这里为value1,value2（基本数据类型）设置默认值0,singleton2(引用类型)设置为null, </li>
<li>类的初始化（按照赋值语句进行修改）： </li>
</ol>
<p>执行 </p>
<p>public static int value2 = 0; </p>
<p>此时value2=0(value1不变，依然是0); </p>
<p>执行 </p>
<p>private static Singleton singleton = new Singleton(); </p>
<p>执行Singleton2的构造器：value1++;value2++; </p>
<p>此时value1，value2均等于1,即为最后结果</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/10/看书笔记/深入理解Java虚拟机/6、类文件结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wfc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="只想当扫地机器人的老王">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/10/看书笔记/深入理解Java虚拟机/6、类文件结构/" class="post-title-link" itemprop="url">6、类文件结构</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-10 07:57:02" itemprop="dateCreated datePublished" datetime="2019-07-10T07:57:02+08:00">2019-07-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-03 19:09:47" itemprop="dateModified" datetime="2019-07-03T19:09:47+08:00">2019-07-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/看书笔记/" itemprop="url" rel="index"><span itemprop="name">看书笔记</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/看书笔记/深入理解Java虚拟机/" itemprop="url" rel="index"><span itemprop="name">深入理解Java虚拟机</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p>计算机只认识0和1，我们编写的程序需要经编译器翻译为由0和1构成的二进制文件才能被计算机执行。伴随着虚拟机和大量建立在虚拟机上程序语言的出现，将程序编译为本地字节码文件已不再是唯一的选择，越来越多的程序语言选择了与操作系统无关的，平台中立的格式作为程序编译后的存储格式。 <strong>各个不同平台的虚拟机与所有平台都统一使用相同的程序存储格式——字节码</strong>，它是构成平台无关性的基石。</p>
<p>在Java中，JVM可以理解的代码就叫做<em>字节码</em>（即扩展名为.class的文件），它不面向任何特定的处理器，只面向虚拟机。Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java程序无须重新编译便可在多种不同操作系统的计算机上运行。</p>
<p>Clojure（Lisp 语言的一种方言）、Groovy、Scala 等语言都是运行在 Java 虚拟机之上。下图展示了不同的语言被不同的编译器编异常.class文件最终运行在 Java 虚拟机之上。.class文件的二进制格式可以使用 WinHex 查看。</p>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%8411.jpg" alt></p>
<p><strong>可以说.class文件是不同的语言在 Java 虚拟机之间的重要桥梁，同时也是支持 Java 跨平台很重要的一个原因。</strong></p>
<h2 id="2、Class文件结构总结"><a href="#2、Class文件结构总结" class="headerlink" title="2、Class文件结构总结"></a>2、Class文件结构总结</h2><p>注意:<em>任何一个class文件都对应着唯一一个类或接口的定义信息，但反过来说，类或接口并不一定都得定义在文件里</em>(譬如类或接口也可以通过类加载器直接生成)。</p>
<p>class文件是一组<strong>以8位字节为基础单位的二进制流</strong>，各个数据项目严格按照顺序紧凑地排列在class文件之中，中间没有任何分隔符，使得整个class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在，当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。</p>
<ul>
<li>Big-Endian：高位在前存储方式，高位字节放在内存的低地址端，低位字节放在内存的高地址端</li>
<li>Little-Endian：低位在前存储方式，高位字节放在内存的高地址端，低位字节放在内存的低地址端</li>
</ul>
<p>Class文件格式采用一种类似C语言结构体的<strong>伪结构来存储数据，伪结构有两种类型：无符号数和表。</strong></p>
<ul>
<li><em>无符号数属于基本的数据类型</em>，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，<strong>无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成的字符串值。</strong></li>
<li><em>表是由多个无符号数或者其它表作为数据项构成的复合数据类型</em>，所有表都习惯性地以”_info”结尾。<strong>表用于描述有层次关系的复合结构的数据，整个class文件本质上就是一张表。</strong></li>
</ul>
<p>根据 Java 虚拟机规范，类文件由单个 ClassFile 结构组成： 无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的格式，这时称这一系列连续的某一类型的数据为某一类型的集合。</p>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%842.png" alt></p>
<p>下面详细介绍一下 Class 文件结构涉及到的一些组件。</p>
<p><strong>Class文件字节码结构组织示意图</strong></p>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%843.png" alt></p>
<h3 id="2-1-魔数"><a href="#2-1-魔数" class="headerlink" title="2.1 魔数"></a>2.1 魔数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u4             magic; //Class 文件的标志</span><br></pre></td></tr></table></figure>

<p>每个 Class 文件的头<em>四个字节</em>称为魔数（Magic Number）,<strong>它的唯一作用是确定这个文件是否为一个能被虚拟机接收的 Class 文件。</strong></p>
<p>程序设计者很多时候都喜欢用一些特殊的数字表示固定的文件类型或者其它特殊的含义。</p>
<h3 id="2-2-Class-文件版本"><a href="#2-2-Class-文件版本" class="headerlink" title="2.2 Class 文件版本"></a>2.2 Class 文件版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             minor_version;//Class 的小版本号</span><br><span class="line">u2             major_version;//Class 的大版本号</span><br></pre></td></tr></table></figure>

<p>紧接着魔数的<em>四个字节存储</em>的是 Class 文件的版本号：第五和第六是次版本号，第七和第八是主版本号。</p>
<p>高版本的 Java 虚拟机可以执行低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行高版本编译器生成的 Class 文件。所以，我们在实际开发的时候要确保开发的的 JDK 版本和生产环境的 JDK 版本保持一致。</p>
<h3 id="2-3-常量池"><a href="#2-3-常量池" class="headerlink" title="2.3 常量池"></a>2.3 常量池</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             minor_version;//Class 的小版本号</span><br><span class="line">u2             major_version;//Class 的大版本号</span><br></pre></td></tr></table></figure>

<p>紧接着魔数的<em>四个字节存储</em>的是 Class 文件的版本号：第五和第六是次版本号，第七和第八是主版本号。</p>
<p>高版本的 Java 虚拟机可以执行低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行高版本编译器生成的 Class 文件。所以，我们在实际开发的时候要确保开发的的 JDK 版本和生产环境的 JDK 版本保持一致。</p>
<h3 id="2-3-常量池-1"><a href="#2-3-常量池-1" class="headerlink" title="2.3 常量池"></a>2.3 常量池</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             constant_pool_count;//常量池的数量</span><br><span class="line">cp_info        constant_pool[constant_pool_count-1];//常量池</span><br></pre></td></tr></table></figure>

<p>紧接着主次版本号之后的是常量池，常量池的数量是constant_pool_count-1<strong>（常量池计数器是从1开始计数的，将第0项常量空出来是有特殊考虑的，索引值为0代表“不引用任何一个常量池项”）。</strong></p>
<p>常量池主要存放两大常量：字面量和符号引用。字面量比较接近于 Java 语言层面的的常量概念，如文本字符串、声明为 final 的常量值等。而符号引用则属于编译原理方面的概念。包括下面三类常量：</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
<p>常量池中每一项常量都是一个表，这14种表有一个共同的特点：<strong>开始的第一位是一个 u1 类型的标志位 -tag 来标识常量的类型，代表当前这个常量属于哪种常量类型．</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>标志（tag）</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CONSTANT_utf8_info</td>
<td>1</td>
<td>UTF-8编码的字符串</td>
</tr>
<tr>
<td>CONSTANT_Integer_info</td>
<td>3</td>
<td>整形字面量</td>
</tr>
<tr>
<td>CONSTANT_Float_info</td>
<td>4</td>
<td>浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Long_info</td>
<td>5</td>
<td>长整型字面量</td>
</tr>
<tr>
<td>CONSTANT_Double_info</td>
<td>6</td>
<td>双精度浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Class_info</td>
<td>7</td>
<td>类或接口的符号引用</td>
</tr>
<tr>
<td>CONSTANT_String_info</td>
<td>8</td>
<td>字符串类型字面量</td>
</tr>
<tr>
<td>CONSTANT_Fieldref_info</td>
<td>9</td>
<td>字段的符号引用</td>
</tr>
<tr>
<td>CONSTANT_Methodref_info</td>
<td>10</td>
<td>类中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_InterfaceMethodref_info</td>
<td>11</td>
<td>接口中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_NameAndType_info</td>
<td>12</td>
<td>字段或方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_MothodType_info</td>
<td>16</td>
<td>标志方法类型</td>
</tr>
<tr>
<td>CONSTANT_MethodHandle_info</td>
<td>15</td>
<td>表示方法句柄</td>
</tr>
<tr>
<td>CONSTANT_InvokeDynamic_info</td>
<td>18</td>
<td>表示一个动态方法调用点</td>
</tr>
</tbody></table>
<p>.class 文件可以通过javap -v class类名 指令来看一下其常量池中的信息(javap -v class类名-&gt; temp.txt ：将结果输出到 temp.txt 文件)。</p>
<p>关于怎么查常量项</p>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%8412.png" alt></p>
<h3 id="2-4-访问标志"><a href="#2-4-访问标志" class="headerlink" title="2.4 访问标志"></a>2.4 访问标志</h3><p>在常量池结束之后，紧接着的两个字节代表访问标志，这个<strong>标志用于识别一些类或者接口层次的访问信息</strong>，包括：这个Class是类还是接口，是否为public 或者 abstract类型，如果是类的话是否声明为final等等。</p>
<p>类访问和属性修饰符:</p>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%844.png" alt></p>
<p>我们定义了一个 Employee 类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">package top.snailclimb.bean;</span><br><span class="line">    public class Employee &#123;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过javap -v class类名 指令来看一下类的访问标志。</p>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%845.png" alt></p>
<h3 id="2-5-当前类索引-父类索引与接口索引集合"><a href="#2-5-当前类索引-父类索引与接口索引集合" class="headerlink" title="2.5 当前类索引,父类索引与接口索引集合"></a>2.5 当前类索引,父类索引与接口索引集合</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u2             this_class;//当前类</span><br><span class="line">u2             super_class;//父类</span><br><span class="line">u2             interfaces_count;//接口</span><br><span class="line">u2             interfaces[interfaces_count];//一个雷可以实现多个接口</span><br></pre></td></tr></table></figure>

<p>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 java.lang.Object 之外，所有的 java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为 0。</p>
<p>接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按implents(如果这个类本身是接口的话则是extends) 后的接口顺序从左到右排列在接口索引集合中。</p>
<p>怎么查</p>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%846.png" alt><br><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%847.png" alt></p>
<h3 id="2-6-字段表集合"><a href="#2-6-字段表集合" class="headerlink" title="2.6 字段表集合"></a>2.6 字段表集合</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             fields_count;//Class 文件的字段的个数</span><br><span class="line">field_info     fields[fields_count];//一个类会可以有个字段</span><br></pre></td></tr></table></figure>

<p><strong>字段表（field info）用于描述接口或类中声明的变量</strong>。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。</p>
<p>field info(字段表) 的结构:</p>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%849.png" alt></p>
<ul>
<li>access_flags: 字段的作用域（public ,private,protected修饰符），是实例变量还是类变量（static修饰符）,可否被序列化（transient 修饰符）,可变性（final）,可见性（volatile 修饰符，是否强制从主内存读写）。</li>
<li>name_index: 对常量池的引用，表示的字段的名称；</li>
<li>descriptor_index: 对常量池的引用，表示字段和方法的描述符；</li>
<li>attributes_count: 一个字段还会拥有一些额外的属性，attributes_count 存放属性的个数；</li>
<li>attributes[attributes_count]: 存放具体属性具体内容。<br>上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型这些都是无法固定的，只能引用常量池中常量来描述。</li>
</ul>
<p>字段的 access_flags 的取值:</p>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%8410.png" alt></p>
<p>由Java本身的语言规则决定：ACC_PUBLIC、ACC_PRIVATE、ACC_PROTECTED中只能选一个；ACC_FINAL、ACC_VOLATILE不能同时选择；接口中字段必须有ACC_PUBLIC、ACC_STATIC、ACC_FINAL标志。</p>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%848.png" alt></p>
<p>对于数组来说，每多一个维度使用前置一个“[”表示。比如String[][]，那么用[[Ljava/lang/String表示。如果方法，则在前面多一个（） ，比如void inc()，那么用（）V表示。</p>
<p>字段表集合中不会列出从超类或者父类接口中继承而来的字段，但有可能列出原本Java代码中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。Java语言中不管两个字段的数据类型、修饰符是否相同，都不能使用一样的名称；但对于字节码而言，两个字段的描述符不一致，字段名可以相同。</p>
<h3 id="2-7-方法表集合"><a href="#2-7-方法表集合" class="headerlink" title="2.7 方法表集合"></a>2.7 方法表集合</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             methods_count;//Class 文件的方法的数量</span><br><span class="line">method_info    methods[methods_count];//一个类可以有个多个方法</span><br></pre></td></tr></table></figure>

<p>methods_count 表示方法的数量，而 method_info 表示的方法表。</p>
<p>Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构如同字段表一样，<em>依次包括了访问标志、名称索引、描述符索引、属性表集合几项</em>。</p>
<p>method_info(方法表的) 结构:</p>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%849.png" alt></p>
<p>因volatile和transient不能修饰方法，方法表的访问标志中没有ACC_VOLATILE、ACC_TRANSIENT；sysnchronized、native、strictfp和abstract可以修饰方法，因此方法表的访问标志中添加了ACC_SYNCHRONIZED、ACC_NATIVE、ACC_STRICTFP和ACC_ABSTRACT标志。</p>
<p>方法表的 access_flag 取值：</p>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%8410.png" alt></p>
<p>如果父类方法在子类中没有被重写，方法表集合中就不会出现来自父类的方法信息，可能会出现编译器自动添加的方法，如类构造器””，方法和实例构造器””方法。</p>
<p>Java中重载方法，要与原方法具有相同的简单名称，与原方法不同的特征签名；在对应的class文件中，特征签名就是方法各个参数在常量池中的字段符号引用的集合，但返回值不在其中，因此Java里无法仅仅依靠返回值对一个方法进行重载。但在class文件中，两个方法名称和特征签名相同，返回值不同的方法，可以合法存在与同一个class文件中。</p>
<p>注意：因为volatile修饰符和transient修饰符不可以修饰方法，所以方法表的访问标志中没有这两个对应的标志，但是增加了synchronized、native、abstract等关键字修饰方法，所以也就多了这些关键字对应的标志。</p>
<p>2.8 属性表集合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             attributes_count;//此类的属性表中的属性数</span><br><span class="line">attribute_info attributes[attributes_count];//属性表集合</span><br></pre></td></tr></table></figure>

<p>在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。</p>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%8411.png" alt></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/10/看书笔记/深入理解Java虚拟机/5、垃圾收集器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wfc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="只想当扫地机器人的老王">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/10/看书笔记/深入理解Java虚拟机/5、垃圾收集器/" class="post-title-link" itemprop="url">5、垃圾收集器</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-10 07:57:02" itemprop="dateCreated datePublished" datetime="2019-07-10T07:57:02+08:00">2019-07-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-03 14:12:45" itemprop="dateModified" datetime="2019-07-03T14:12:45+08:00">2019-07-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/看书笔记/" itemprop="url" rel="index"><span itemprop="name">看书笔记</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/看书笔记/深入理解Java虚拟机/" itemprop="url" rel="index"><span itemprop="name">深入理解Java虚拟机</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>垃圾收集器的定义分类等概念<br><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A811.png" alt></p>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A82.jpg" alt></p>
<h2 id="1-Serial收集器"><a href="#1-Serial收集器" class="headerlink" title="1. Serial收集器"></a>1. Serial收集器</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p>最基本、发展历史最长的垃圾收集器</p>
<h3 id="1-2-优点"><a href="#1-2-优点" class="headerlink" title="1.2 优点"></a>1.2 优点</h3><h4 id="并发收集"><a href="#并发收集" class="headerlink" title="并发收集"></a>并发收集</h4><p>在进行垃圾收集时，必须暂停其他所有工作线程（Stop The World），直到收集结束。Stop The World 暂停工作线程 是在用户不可见的情况下进行</p>
<p>并发与并行的区别</p>
<ul>
<li>并发：在 某一时段内，交替执行多个任务（即先处理A再处理B，循环该过程）</li>
<li>并行：在 某一时刻内，同时执行多个任务（即同时处理A、B）</li>
</ul>
<h4 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h4><p>只使用 一条线程 完成垃圾收集（GC线程）</p>
<h4 id="效率高"><a href="#效率高" class="headerlink" title="效率高"></a>效率高</h4><ul>
<li>对于限定单CPU环境来说，Serial收集器没有线程交互开销（专一做垃圾收集），拥有更高的单线程收集效率。</li>
<li>垃圾收集高效:即其他工作线程停顿时间短（可控制在100ms内） 只要垃圾收集发生的频率不高，完全可以接受</li>
</ul>
<h3 id="1-3-使用的垃圾收集算法"><a href="#1-3-使用的垃圾收集算法" class="headerlink" title="1.3 使用的垃圾收集算法"></a>1.3 使用的垃圾收集算法</h3><p>复制 算法（新生代）</p>
<h3 id="1-4-应用场景"><a href="#1-4-应用场景" class="headerlink" title="1.4 应用场景"></a>1.4 应用场景</h3><p>客户端模式下，虚拟机的 新生代区域</p>
<h3 id="1-5-工作流程"><a href="#1-5-工作流程" class="headerlink" title="1.5 工作流程"></a>1.5 工作流程</h3><p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A83.jpg" alt></p>
<h2 id="2-Serial-Old收集器"><a href="#2-Serial-Old收集器" class="headerlink" title="2. Serial Old收集器"></a>2. Serial Old收集器</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><p>Serial收集器 应用在老年代区域 的版本</p>
<h3 id="2-2-优点"><a href="#2-2-优点" class="headerlink" title="2.2 优点"></a>2.2 优点</h3><p>并发、单线程、效率高</p>
<p>同Serial收集器，此处不作过多描述</p>
<h3 id="2-3-使用的垃圾收集算法"><a href="#2-3-使用的垃圾收集算法" class="headerlink" title="2.3 使用的垃圾收集算法"></a>2.3 使用的垃圾收集算法</h3><p>标记-整理 算法（老年代）</p>
<h3 id="2-4-应用场景"><a href="#2-4-应用场景" class="headerlink" title="2.4 应用场景"></a>2.4 应用场景</h3><p>在客户端模式下，虚拟机的老年代区域</p>
<p>在服务器模式下：</p>
<ul>
<li>与 Parallel Scavenge 收集器搭配使用</li>
<li>作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用</li>
</ul>
<h3 id="2-5-工作流程"><a href="#2-5-工作流程" class="headerlink" title="2.5 工作流程"></a>2.5 工作流程</h3><p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A84.jpg" alt></p>
<h2 id="3-ParNew-收集器"><a href="#3-ParNew-收集器" class="headerlink" title="3. ParNew 收集器"></a>3. ParNew 收集器</h2><h3 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h3><p>Serial收集器的多线程版本。</p>
<h3 id="3-2-优点"><a href="#3-2-优点" class="headerlink" title="3.2 优点"></a>3.2 优点</h3><h4 id="并发收集-1"><a href="#并发收集-1" class="headerlink" title="并发收集"></a>并发收集</h4><p>在进行垃圾收集时，必须暂停其他所有工作线程（Stop The World），直到收集结束。 暂停工作线程是在用户不可见的情况下进行</p>
<h4 id="多线程收集"><a href="#多线程收集" class="headerlink" title="多线程收集"></a>多线程收集</h4><ul>
<li>使用条垃圾收集线程（GC线程） 完成垃圾收集</li>
<li>由于存在线程交互的开销，所以在单CPU环境下，性能差于 Serial收集器</li>
</ul>
<h4 id="与CMS收集器配合工作"><a href="#与CMS收集器配合工作" class="headerlink" title="与CMS收集器配合工作"></a>与CMS收集器配合工作</h4><p>目前，只有ParNew 收集器能与 CMS收集器 配合工作<br>由于CMS收集器使用广泛，所以该特点非常重要。<br>关于CMS收集器 下面会详细说明</p>
<h3 id="3-3-使用的垃圾收集算法"><a href="#3-3-使用的垃圾收集算法" class="headerlink" title="3.3 使用的垃圾收集算法"></a>3.3 使用的垃圾收集算法</h3><p>复制算法（新生代）</p>
<h3 id="3-4-应用场景"><a href="#3-4-应用场景" class="headerlink" title="3.4 应用场景"></a>3.4 应用场景</h3><ul>
<li>服务器模式下，虚拟机的 新生代区域</li>
<li>多线程收集</li>
</ul>
<h3 id="3-5-工作流程"><a href="#3-5-工作流程" class="headerlink" title="3.5 工作流程"></a>3.5 工作流程</h3><p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A85.jpg" alt></p>
<h2 id="4-Parallel-Scavenge收集器"><a href="#4-Parallel-Scavenge收集器" class="headerlink" title="4. Parallel Scavenge收集器"></a>4. Parallel Scavenge收集器</h2><h3 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h3><p>ParNew 收集器的升级版</p>
<h3 id="4-2-特点"><a href="#4-2-特点" class="headerlink" title="4.2 特点"></a>4.2 特点</h3><ul>
<li>具备ParNew收集器并发、多线程收集的特点</li>
<li>以达到可控制吞吐量为目标</li>
</ul>
<p>其他收集器的目标是：尽可能缩短垃圾收集时间，</p>
<p>而Parallel Scavenge收集器的目标则是：达到可控制吞吐量</p>
<ol>
<li>吞吐量：CPU用于运行用户代码的时间 与 CPU总消耗时间（运行用户代码时间+垃圾收集时间）的比值</li>
<li>如：虚拟机总共运行100分钟，其中垃圾收集时间=1分钟、运行用户代码时间 = 99分钟，那吞吐量 = 99 / 100 = 99%</li>
</ol>
<p>自适应</p>
<p>该垃圾收集器能根据当前系统运行情况，动态调整自身参数，从而达到最大吞吐量的目标。</p>
<ol>
<li>该特性称为：GC 自适应的调节策略</li>
<li>这是Parallel Scavenge收集器与 ParNew 收集器 最大的区别</li>
</ol>
<h3 id="4-3-使用的垃圾收集算法"><a href="#4-3-使用的垃圾收集算法" class="headerlink" title="4.3 使用的垃圾收集算法"></a>4.3 使用的垃圾收集算法</h3><p>复制 算法（新生代）</p>
<h3 id="4-4-应用场景"><a href="#4-4-应用场景" class="headerlink" title="4.4 应用场景"></a>4.4 应用场景</h3><p>服务器模式下，虚拟机的 新生代区域</p>
<h3 id="4-5-工作流程"><a href="#4-5-工作流程" class="headerlink" title="4.5 工作流程"></a>4.5 工作流程</h3><p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A86.jpg" alt></p>
<h2 id="5-Parallel-Old收集器"><a href="#5-Parallel-Old收集器" class="headerlink" title="5. Parallel Old收集器"></a>5. Parallel Old收集器</h2><h3 id="5-1-定义"><a href="#5-1-定义" class="headerlink" title="5.1 定义"></a>5.1 定义</h3><p>Parallel Scavenge收集器 应用在老年代区域 的版本</p>
<h3 id="5-2-特点"><a href="#5-2-特点" class="headerlink" title="5.2 特点"></a>5.2 特点</h3><p>以达到 可控制吞吐量 为目标、自适应调节、多线程收集</p>
<p>同Parallel Scavenge收集器</p>
<h3 id="5-3-使用的垃圾收集算法"><a href="#5-3-使用的垃圾收集算法" class="headerlink" title="5.3 使用的垃圾收集算法"></a>5.3 使用的垃圾收集算法</h3><p>标记-整理 算法（老年代）</p>
<h3 id="5-4-应用场景"><a href="#5-4-应用场景" class="headerlink" title="5.4 应用场景"></a>5.4 应用场景</h3><p>服务器模式下，虚拟机的 老年代区域</p>
<h3 id="5-5-工作流程"><a href="#5-5-工作流程" class="headerlink" title="5.5 工作流程"></a>5.5 工作流程</h3><h2 id="6-CMS收集器"><a href="#6-CMS收集器" class="headerlink" title="6. CMS收集器"></a>6. CMS收集器</h2><h3 id="6-1-定义"><a href="#6-1-定义" class="headerlink" title="6.1 定义"></a>6.1 定义</h3><p>即Concurrent Mark Sweep，基于 标记-清除算法的收集器</p>
<h3 id="6-2-特点"><a href="#6-2-特点" class="headerlink" title="6.2 特点"></a>6.2 特点</h3><h5 id="6-2-1-优点"><a href="#6-2-1-优点" class="headerlink" title="6.2.1 优点"></a>6.2.1 优点</h5><ul>
<li>并行</li>
</ul>
<p>用户线程 &amp; 垃圾收集线程同时进行。即在进行垃圾收集时，用户还能工作（重点）。</p>
<ul>
<li>单线程收集</li>
</ul>
<p>只使用一条线程完成垃圾收集（GC线程）</p>
<p>垃圾收集停顿时间短</p>
<p>该收集器的目标是： 获取最短回收停顿时间 ， 即希望 系统停顿的时间 最短，提高响应速度</p>
<h5 id="6-2-2-缺点"><a href="#6-2-2-缺点" class="headerlink" title="6.2.2 缺点"></a>6.2.2 缺点</h5><ul>
<li>总吞吐量会降低</li>
</ul>
<p>因为该收集器对CPU资源非常敏感，在并发阶段，虽不会导致用户线程停顿，但会因为占用部分线程（CPU资源）而导致应用程序变慢，总吞吐量会降低</p>
<ul>
<li>无法处理浮动垃圾</li>
</ul>
<p>由于并发清理时用户线程还在运行，所以会有新的垃圾不断产生（即浮动垃圾），只能等到留待下一次GC时再清理掉。</p>
<ol>
<li>因为这一部分垃圾出现在标记过程之后，所以CMS无法在当次GC中处理掉它们</li>
<li>因此，CMS无法等到老年代被填满再进行Full GC，CMS需要预留一部分空间。即所谓的：可能出现Concurrent Mode Failure失败而导致另一次Full GC产生。</li>
</ol>
<ul>
<li>垃圾收集后会产生大量内存空间碎片</li>
</ul>
<h3 id="6-3-使用的垃圾收集算法"><a href="#6-3-使用的垃圾收集算法" class="headerlink" title="6.3 使用的垃圾收集算法"></a>6.3 使用的垃圾收集算法</h3><p>标记-清除 算法（老年代）</p>
<h3 id="6-4-应用场景"><a href="#6-4-应用场景" class="headerlink" title="6.4 应用场景"></a>6.4 应用场景</h3><p>重视应用的响应速度、希望系统停顿时间最短的场景</p>
<p>如互联网移动端应用</p>
<h3 id="6-5-工作流程"><a href="#6-5-工作流程" class="headerlink" title="6.5 工作流程"></a>6.5 工作流程</h3><p>CMS收集器是基于标记-清除算法实现的收集器，工作流程较为复杂：（分为四个步骤）</p>
<ol>
<li>初始标记：为了收集应用程序的对象引用需要暂停应用程序线程，该阶段完成后，应用程序线程再次启动。 </li>
<li>并发标记：从第一阶段收集到的对象引用开始，遍历所有其他的对象引用。 </li>
<li>并发预清理：改变当运行第二阶段时，由应用程序线程产生的对象引用，以更新第二阶段的结果。 </li>
<li>重标记：由于第三阶段是并发的，对象引用可能会发生进一步改变。因此，应用程序线程会再一次被暂停以更新这些变化，并且在进行实际的清理之前确保一个正确的对象引用视图。这一阶段十分重要，因为必须避免收集到仍被引用的对象。 </li>
<li>并发清理：所有不再被应用的对象将从堆里清除掉。 </li>
<li>并发重置：收集器做一些收尾的工作，以便下一次 GC 周期能有一个干净的状态。 </li>
</ol>
<h2 id="7-G1收集器"><a href="#7-G1收集器" class="headerlink" title="7. G1收集器"></a>7. G1收集器</h2><h3 id="7-1-定义"><a href="#7-1-定义" class="headerlink" title="7.1 定义"></a>7.1 定义</h3><p>最新、技术最前沿的垃圾收集器</p>
<h3 id="7-2-特点"><a href="#7-2-特点" class="headerlink" title="7.2 特点"></a>7.2 特点</h3><ul>
<li>并行<br>用户线程 &amp; 垃圾收集线程同时进行。</li>
</ul>
<p>即在进行垃圾收集时，用户还能工作</p>
<ul>
<li>多线程<br>即使用 多条垃圾收集线程（GC线程） 进行垃圾收集</li>
</ul>
<p>并发 &amp; 并行 充分利用多CPU、多核环境下的硬件优势 来缩短 垃圾收集的停顿时间</p>
<ul>
<li>垃圾回收效率高</li>
</ul>
<p>G1 收集器是 针对性 对 Java堆内存区域进行垃圾收集，而非每次都对整个 Java 堆内存区域进行垃圾收集。</p>
<ol>
<li>即 G1收集器除了将 Java 堆内存区域分为新生代 &amp; 老年代之外，还会细分为许多个大小相等的独立区域（ Region），然后G1收集器会跟踪每个 Region里的垃圾价值大小，并在后台维护一个列表；每次回收时，会根据允许的垃圾收集时间 优先回收价值最大的Region，从而避免了对整个Java堆内存区域进行垃圾收集，从而提高效率。</li>
<li>因为上述机制，G1收集器还能建立可预测的停顿时间模型：即让 使用者 明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得从超出N毫秒。即具备实时性</li>
</ol>
<ul>
<li>分代收集</li>
</ul>
<p>同时应用在 内存区域的新生代 &amp; 老年代</p>
<ul>
<li>不会产生内存空间碎片</li>
</ul>
<ol>
<li>从整体上看，G1 收集器是基于 标记-整理算法实现的收集器</li>
<li>从局部上看，是基于 复制算法 实现</li>
</ol>
<p>上述两种算法意味着 G1 收集器不会产生内存空间碎片。</p>
<h3 id="7-3-使用的垃圾收集算法"><a href="#7-3-使用的垃圾收集算法" class="headerlink" title="7.3 使用的垃圾收集算法"></a>7.3 使用的垃圾收集算法</h3><ul>
<li>对于新生代：复制算法</li>
<li>对于老年代：标记 - 整理算法</li>
</ul>
<h3 id="7-4-应用场景"><a href="#7-4-应用场景" class="headerlink" title="7.4 应用场景"></a>7.4 应用场景</h3><p>服务器端虚拟机的内存区域（包括新生代 &amp; 老年代）</p>
<h3 id="7-5-工作流程"><a href="#7-5-工作流程" class="headerlink" title="7.5 工作流程"></a>7.5 工作流程</h3><p>G1 收集器的工作流程分为4个步骤：</p>
<ol>
<li>初始标记，整个过程STW,标记了从GC Roots 的可达对象</li>
<li>并发标记 ，真个过程用户线程的垃圾回收线程共同执行，标记出GC Roots可达对象的关联对象，收集整个Region的存活对象。</li>
<li>最终标记，整个过程STW,标记出并发标记遗漏的，以及引用关系发生变化的存活对象。</li>
<li>筛选回收，垃圾清理过程，如果整个Region没有存活对象，将Region加入到存活列表当中。</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/10/看书笔记/深入理解Java虚拟机/4、垃圾收集算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wfc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="只想当扫地机器人的老王">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/10/看书笔记/深入理解Java虚拟机/4、垃圾收集算法/" class="post-title-link" itemprop="url">4、垃圾收集算法</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-10 07:57:02" itemprop="dateCreated datePublished" datetime="2019-07-10T07:57:02+08:00">2019-07-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-01 16:44:46" itemprop="dateModified" datetime="2019-07-01T16:44:46+08:00">2019-07-01</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/看书笔记/" itemprop="url" rel="index"><span itemprop="name">看书笔记</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/看书笔记/深入理解Java虚拟机/" itemprop="url" rel="index"><span itemprop="name">深入理解Java虚拟机</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>当JVM空闲时，自动回收每块可能被回收的内存，GC是完全自动的，不能被强制执行。程序员最多只能用System.gc()来建议执行垃圾回收器回收内存，但是具体的回收时间，是不可知的。</p>
<h2 id="1-标记-清除算法"><a href="#1-标记-清除算法" class="headerlink" title="1. 标记-清除算法"></a>1. 标记-清除算法</h2><p>这是 垃圾收集算法中 最最基础的算法。</p>
<h3 id="1-1-算法思想"><a href="#1-1-算法思想" class="headerlink" title="1.1 算法思想"></a>1.1 算法思想</h3><p>算法分为两个阶段：</p>
<p>标记阶段：标记出所有需要回收的对象；<br>清除阶段：统一清除（回收）所有被标记的对象。<br>下面主要讲解标记阶段。标记阶段主要分为：（先进行可达性分析）</p>
<p>第一次标记 &amp; 筛选 执行finalize<br>第二次标记 &amp; 筛选 放入F队列，F队列中的对象是否重新连接</p>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%AD%98%E6%B4%BB2.png" alt></p>
<h3 id="1-2-优点"><a href="#1-2-优点" class="headerlink" title="1.2 优点"></a>1.2 优点</h3><p>算法简单、实现简单</p>
<h3 id="1-3-缺点"><a href="#1-3-缺点" class="headerlink" title="1.3 缺点"></a>1.3 缺点</h3><p>效率问题：即标记和清除两个过程效率不高<br>空间问题：标记 - 清除后，会产生大量不连续的内存碎片。</p>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%952.png" alt></p>
<p><em>这导致 以后程序 需要分配较大空间对象时无法找到足够大的连续内存而被迫触发另外一次垃圾收集行为，这导致非常浪费资源。</em></p>
<h3 id="1-4-应用场景"><a href="#1-4-应用场景" class="headerlink" title="1.4 应用场景"></a>1.4 应用场景</h3><p>对象存活率较低 &amp; 垃圾回收行为频率低 的场景</p>
<p>如老年代区域，因为老年代区域回收频次少、回收数量少，所以对于效率问题 &amp; 空间问题不会很明显。</p>
<h2 id="2、复制算法"><a href="#2、复制算法" class="headerlink" title="2、复制算法"></a>2、复制算法</h2><p>该算法的出现是为了解决 标记-清除算法中 效率 &amp; 空间问题的。</p>
<h3 id="2-1-算法思想"><a href="#2-1-算法思想" class="headerlink" title="2.1 算法思想"></a>2.1 算法思想</h3><ul>
<li>将内存分为大小相等的两块，每次使用其中一块；</li>
<li>当使用的这块内存用完，就将 这块内存上还存活的对象 复制到另一块还没试用过的内存上</li>
<li>最终将使用的那块内存一次清理掉</li>
</ul>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%953.png" alt></p>
<h2 id="2-2-优点"><a href="#2-2-优点" class="headerlink" title="2.2 优点"></a>2.2 优点</h2><ol>
<li>解决了标记-清除算法中 清除效率低的问题：每次仅回收内存的一半区域</li>
<li>解决了标记-清除算法中 空间产生不连续内存碎片的问题：将已使用内存上的存活对象 移动到栈顶的指针，按顺序分配内存即可。</li>
</ol>
<h2 id="2-3-缺点"><a href="#2-3-缺点" class="headerlink" title="2.3 缺点"></a>2.3 缺点</h2><ul>
<li>每次使用的内存缩小为原来的一半。</li>
<li>当对象存活率较高的情况下需要做很多复制操作，即效率会变低</li>
</ul>
<h2 id="2-4-应用场景"><a href="#2-4-应用场景" class="headerlink" title="2.4 应用场景"></a>2.4 应用场景</h2><p>对象存活率较低 &amp; 需要频繁进行垃圾回收 的区域</p>
<p>如新生代区域</p>
<h2 id="2-5-特别注意"><a href="#2-5-特别注意" class="headerlink" title="2.5 特别注意"></a>2.5 特别注意</h2><p>a. 背景</p>
<p>新生代区域在进行垃圾回收时，98%对象都必须得回收</p>
<p>b. 问题</p>
<p>复制算法中 每次使用的内存缩小为原来的一半 利用率低 &amp; 代价太高</p>
<p>c. 解决方案</p>
<p>不 按 1：1的比例 划分内存，而是 按8：1：1比例 将内存划分为一块较大的 Eden 和两块较小的 Survivor 区域（From Survivor、To Survivor）</p>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%954.png" alt></p>
<ul>
<li>每次使用Eden、From Survivor区域；</li>
<li>用完后就 将上述两块区域存活的对象 复制到To Survivor区域上</li>
<li>最终一次清理掉Eden、From Survivor区域使用逻辑 同 改进前</li>
</ul>
<p>很多同学会问，假如 Eden、From Survivor区域上存活对象所需内存大小 &gt; To Survivor区域怎么办？</p>
<p>解决方案：<em>依赖老年代内存区域 做 内存分配担</em>。</p>
<p>即To Survivor区域 存不下来的对象 会通过 内存分配担保机制 暂时保存在老年代</p>
<h2 id="3、标记-整理算法"><a href="#3、标记-整理算法" class="headerlink" title="3、标记-整理算法"></a>3、标记-整理算法</h2><h3 id="3-1-算法思路"><a href="#3-1-算法思路" class="headerlink" title="3.1 算法思路"></a>3.1 算法思路</h3><p>算法分为三个阶段：</p>
<ol>
<li>标记阶段：标记出所有需要回收的对象；</li>
<li>整理阶段：让所有存活的对象都向一端移动</li>
<li>清除阶段：统一清除（回收）端以外的对象。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%955.png" alt></p>
<h3 id="3-2-优点"><a href="#3-2-优点" class="headerlink" title="3.2 优点"></a>3.2 优点</h3><ul>
<li>解决了标记-清除算法中 清除效率低的问题：一次清楚端外区域</li>
<li>解决了标记-清除算法中 空间产生不连续内存碎片的问题：将已使用内存上的存活对象 移动到栈顶的指针，按顺序分配内存即可。</li>
</ul>
<h3 id="3-3-应用场景"><a href="#3-3-应用场景" class="headerlink" title="3.3 应用场景"></a>3.3 应用场景</h3><p>对象存活率较低 &amp; 垃圾回收行为频率低的场景</p>
<p>如老年代区域，因为老年代区域回收频次少、回收数量少，所以对于效率问题 &amp; 空间问题不会很明显。</p>
<h2 id="4-分代收集算法"><a href="#4-分代收集算法" class="headerlink" title="4. 分代收集算法"></a>4. 分代收集算法</h2><p>主流的虚拟机基本都采用该算法，下面会着重讲解。</p>
<h3 id="4-1-算法思路"><a href="#4-1-算法思路" class="headerlink" title="4.1 算法思路"></a>4.1 算法思路</h3><p>逐一标记和压缩 Java 虚拟机里的所有对象非常低效：分配的对象越多，垃圾回收需时就越久。不过，根据统计，大部分的对象，其实用没多久就不用了。根据之前的规律，就可以用来提升 JVM 的效率了。方法是，把堆分成几个部分（就是所谓的分代），分别是<em>新生代、老年代，以及永生代</em>.</p>
<p>根据 对象存活周期的不同 将 Java堆内存 分为：新生代 &amp; 老年代 。分配比例如下：</p>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%9566.png" alt></p>
<p><em>老年代存活率高使用标记整理或者标记清除，年轻代少量存活使用复制算法</em></p>
<p>特别注意</p>
<p>有时候survivor被称为From Survivor和To Survivor，他们之间会经常互换角色：每次发生GC时，把Eden区和 From Survivor区中 存活且没超过年龄阈值的对象 复制到To Survivor区中（此时To Survivor变成了From Survivor），然后From Survivor清空（此时From Survivor变成了To Survivor）</p>
<p>两块区域特点 选择 对应的垃圾收集算法（即上面介绍的算法），具体细节请看下图</p>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%957.png" alt></p>
<h3 id="4-2-具体存储过程"><a href="#4-2-具体存储过程" class="headerlink" title="4.2 具体存储过程"></a>4.2 具体存储过程</h3><p>新对象会被分配在新生代内存。一旦新生代内存满了，就会开始对死掉的对象，进行所谓的小型垃圾回收过程。一片新生代内存里，死掉的越多，回收过程就越快；至于那些还活着的对象，此时就会老化，并最终老到进入老年代内存。</p>
<p>Stop the World 事件 —— <em>小型垃圾回收属于一种叫 “Stop the World” 的事件。在这种事件发生时，所有的程序线程都要暂停，直到事件完成（比如这里就是完成了所有回收工作）为止（停止也不是随意停止，当到达安全点的时候暂停，OopMap才会记录信息）。停顿的时候不是全部遍历，这样太麻烦了。而是枚举根节点时，递归遍历每个栈帧的 OopMap（数据结构） ，通过栈中记录的被引用对象的内存地址，即可找到这些对象（ GC Roots ）</em>。这是执行的线程，如果线程不执行，那么在<em>安全区域</em>内开始GC是安全的。</p>
<p>老年代用来保存长时间存活的对象。通常，设置一个阈值，当达到该年龄时，年轻代对象会被移动到老年代。最终老年代也会被回收。这个事件成为 Major GC。</p>
<p>Major GC 也会触发STW（Stop the World）。通常，Major GC会慢很多，因为它涉及到所有存活对象。所以，对于响应性的应用程序，应该尽量避免Major GC。还要注意，Major GC的STW的时长受年老代垃圾回收器类型的影响。</p>
<p>永久代包含JVM用于描述应用程序中类和方法的元数据。永久代是由JVM在运行时根据应用程序使用的类来填充的。此外，Java SE类库和方法也存储在这里。</p>
<p>如果JVM发现某些类不再需要，并且其他类可能需要空间，则这些类可能会被回收。</p>
<p>介绍</p>
<ol>
<li>新建的对象 一般会被优先分配到新生代的Eden区、From Survivor区</li>
<li>大对象（如很长的字符串以及数组）会直接分配到老年代，这是为了避免在 Eden 区 和 Survivor区之间发生大量的内存复制（因为新生代会采用复制算法进行垃圾收集）</li>
<li>这些对象经过第一次 Minor GC后，若仍然存活，将会被移到To Survivor区</li>
<li>一次清理掉Eden、From Survivor区域</li>
<li>在 To Survivor 区每经过一轮 Minor GC ，该对象的年龄就+1</li>
<li>当对象年龄达到一定时(阈值默认=15)，就会被移动到老年代。</li>
</ol>
<ul>
<li>即新生代的对象在存活一定时间后，会被移动存储到老年代区域。</li>
<li>还有一种 新生代对象被移懂到老年代区域 的情况是：动态对象年龄判定。即如果在Survivor区中 所有相同年龄对象的大小总和 大于Survivor区内存大小一半时，所有大于或等于该年龄的对象都会直接进入老年代。</li>
</ul>
<h4 id="世代垃圾收集过程"><a href="#世代垃圾收集过程" class="headerlink" title="世代垃圾收集过程"></a>世代垃圾收集过程</h4><p>首先，将任何新对象分配给 eden 空间。 两个 survivor 空间都是空的。</p>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%958.png" alt></p>
<p>当 eden 空间填满时，会触发轻微的垃圾收集。</p>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%959.png" alt></p>
<p>引用的对象被移动到第一个 survivor 空间。 清除 eden 空间时，将删除未引用的对象。</p>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%9510.jpg" alt></p>
<p>在下一次Minor GC中，Eden区也会做同样的操作。删除未被引用的对象，并将被引用的对象移动到Survivor区。然而，这里，他们被移动到了第二个Survivor区（S1）。</p>
<p>此外，第一个Survivor区（S0）中，在上一次Minor GC幸存的对象，会增加年龄，并被移动到S1中。待所有幸存对象都被移动到S1后，S0和Eden区都会被清空。注意，Survivor区中有了不同年龄的对象。</p>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%9511.jpg" alt></p>
<p>在下一次Minor GC中，会重复同样的操作。不过，这一次Survivor区会交换。被引用的对象移动到S0,。幸存的对象增加年龄。Eden区和S1被清空。</p>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%9512.jpg" alt></p>
<p>在较小的GC之后，当老化的物体达到一定的年龄阈值（在该示例中为8）时，它们从年轻一代晋升到老一代。</p>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%9513.jpg" alt></p>
<p>随着较小的GC持续发生，物体将继续被推广到老一代空间。</p>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%9514.png" alt></p>
<p>所以这几乎涵盖了年轻一代的整个过程。最终，将主要对老一代进行GC，清理并最终压缩该空间。</p>
<p><img src="https://raw.githubusercontent.com/wfc1994/Figurebed/master/img/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%9515.png" alt></p>
<h3 id="4-3-优点"><a href="#4-3-优点" class="headerlink" title="4.3 优点"></a>4.3 优点</h3><p>效率高、空间利用率高</p>
<p>根据不同区域特点选择不同的垃圾收集算法</p>
<h3 id="4-4-应用场景"><a href="#4-4-应用场景" class="headerlink" title="4.4 应用场景"></a>4.4 应用场景</h3><p>现在主流的虚拟机基本都采用 分代收集算法 ，即根据不同区域特点选择不同垃圾收集算法。</p>
<p>新生代 区域：采用 复制算法</p>
<p>老年代 区域：采用 标记-清除 算法、标记 - 整理 算法</p>
<h3 id="4-5-GC-触发条件"><a href="#4-5-GC-触发条件" class="headerlink" title="4.5 GC 触发条件"></a>4.5 GC 触发条件</h3><p>Minor GC触发条件：</p>
<p>当Eden区满时，触发Minor GC。</p>
<p>Full GC触发条件：</p>
<ol>
<li>调用System.gc时，系统建议执行Full GC，但是不必然执行</li>
<li>老年代空间不足</li>
<li>方法去空间不足</li>
<li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li>
<li>由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li>
</ol>
<h2 id="5、HotSpot算法实现"><a href="#5、HotSpot算法实现" class="headerlink" title="5、HotSpot算法实现"></a>5、HotSpot算法实现</h2><p>根据垃圾回收算法和判定对象存活的原理来实现HotSpot。</p>
<p>1、枚举根节点 我们知道，对象可达性分析中GC Roots根节点主要包括栈和方法区所引用的对象。那么实际设计中如何逐个检查这些引用呢？</p>
<p>为了保证准确性，显然我们在枚举根节点的时候，应该停止所有的Java用户线程。<br>（Stop-The-World，使整个分析过程，系统好像冻结到某个时间点），为了让这个时间尽量短（否则用户线程阻塞太久），主流的虚拟机都是采用准确式GC，并不需要挨个扫描方法栈，就可以得知哪些位置上存放着对象引用。这个又是如何实现的呢？</p>
<p>在HotSpot的实现中，是使用一组称为<strong><em>OopMap的数据结构</em></strong>来达到这个目的的，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样，GC在扫描时就可以直接得知这些信息了。</p>
<p><em>OopMap 记录了栈上本地变量到堆上对象的引用关系。</em></p>
<p>其作用是：垃圾收集时，收集线程会对栈上的内存进行扫描，看看哪些位置存储了 Reference 类型。如果发现某个位置确实存的是 Reference 类型，就意味着它所引用的对象这一次不能被回收。但问题是，栈上的本地变量表里面只有一部分数据是 Reference 类型的（它们是我们所需要的），那些非 Reference 类型的数据对我们而言毫无用处，但我们还是不得不对整个栈全部扫描一遍，这是对时间和资源的一种浪费。 它的另外一个更根本的作用是，可以帮助 HotSpot 实现准确式 GC。</p>
<p>2、安全点</p>
<p>一个线程意味着一个栈，一个栈由多个栈帧组成，一个栈帧对应着一个方法，一个方法里面可能有多个安全点。</p>
<p>gc 发生时，程序首先运行到最近的一个安全点停下来，然后更新自己的 OopMap ，记下栈上哪些位置代表着引用。</p>
<p>枚举根节点时，递归遍历每个栈帧的OopMap，通过栈中记录的被引用对象的内存地址，即可找到这些对象（ GC Roots ）。</p>
<p>前面我们知道了OopMap的概念，然而为每一条指令的位置都生成对应的OopMap显然不显示。前面提到的“特定位置”即安全点：程序执行并非所有地方都可以停下来GC，只有到达安全点才可以。</p>
<p>关于安全点的选择？ 既不能让GC等待太久，也不能太过频繁增加负荷。 普通指令执行很快，一般遇到“长时间执行”的指令才会产生安全点，包括：方法调用、循环跳转等。</p>
<p>GC时如何让所有线程跑到安全点再停下来？抢先式中断和主动式中断。</p>
<p><em>抢先式中断</em>：一般不采用。GC时暂停所有线程，如果发现有线程没在安全点，则让它跑到安全点。</p>
<p><em>主动式中断</em>：GC中断线程不直接对线程操作，而是设置一个中断标志位。线程在每一个安全点检查这个标志位即可。</p>
<p>3、安全区域</p>
<p>考虑一下，程序不执行的时候（没有分配到cpu时间片）如何跑到安全点呢？ 于是，提出了扩展的安全点——安全区域的概念。</p>
<p>安全区域：一段代码中，对象引用没有发生变化，任何地方开始GC都是安全的。<br>当线程执行到安全区域时，首先标识自己已经进入安全区域，这中间如果发生GC，就不用管标识为安全区域的线程了。 线程离开安全区域之前，需要确定自己已经完成了根节点枚举的过程，否则必须等待完成。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/07/编程练习/LeetCode练习/861. 翻转矩阵后的得分/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wfc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="只想当扫地机器人的老王">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/07/编程练习/LeetCode练习/861. 翻转矩阵后的得分/" class="post-title-link" itemprop="url">861.翻转矩阵后的得分</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-07 22:51:06 / 修改时间：22:47:56" itemprop="dateCreated datePublished" datetime="2019-07-07T22:51:06+08:00">2019-07-07</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/编程练习/" itemprop="url" rel="index"><span itemprop="name">编程练习</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/编程练习/LeetCode练习/" itemprop="url" rel="index"><span itemprop="name">LeetCode练习</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="861-翻转矩阵后的得分"><a href="#861-翻转矩阵后的得分" class="headerlink" title="861. 翻转矩阵后的得分"></a><a href="https://leetcode-cn.com/problems/score-after-flipping-matrix/" target="_blank" rel="noopener">861. 翻转矩阵后的得分</a></h2><p>有一个二维矩阵 A 其中每个元素的值为 0 或 1。</p>
<p>移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。</p>
<p>在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。</p>
<p>返回尽可能高的分数。</p>
<p>示例：</p>
<p>输入：[[0,0,1,1],[1,0,1,0],[1,1,0,0]]</p>
<p>输出：39</p>
<p>解释：</p>
<p>转换为 [[1,1,1,1],[1,0,0,1],[1,1,1,1]]</p>
<p>0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39</p>
<p>提示：</p>
<p>1 &lt;= A.length &lt;= 20</p>
<p>1 &lt;= A[0].length &lt;= 20</p>
<p>A[i][j] 是 0 或 1</p>
<p>思路：我的思路是把数组的行先转置，每一行如果转置后的结果比原先的一行结果大，则转置成功，之后，再按照列转置，转置列的时候要注意，因为同一列的时候，是同一阶的数（按照行求二进制），所以我要保证同一列的时候，1是最多的即可。</p>
<p>提交记录：<a href="https://leetcode-cn.com/submissions/detail/22283165/" target="_blank" rel="noopener">https://leetcode-cn.com/submissions/detail/22283165/</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/07/ARTS打卡/【4】ARTS打卡第四周/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wfc">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="只想当扫地机器人的老王">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/07/ARTS打卡/【4】ARTS打卡第四周/" class="post-title-link" itemprop="url">ARTS打卡第四周</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-07 22:49:19 / 修改时间：22:47:56" itemprop="dateCreated datePublished" datetime="2019-07-07T22:49:19+08:00">2019-07-07</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/ARTS打卡/" itemprop="url" rel="index"><span itemprop="name">ARTS打卡</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="ARTS打卡第四周"><a href="#ARTS打卡第四周" class="headerlink" title="ARTS打卡第四周"></a>ARTS打卡第四周</h2><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p><a href="http://note.youdao.com/noteshare?id=7b3d061c3fed37f22b98f859bbf9e5e1&sub=BAF03A08011A45AEABD9A0B56E166C51" target="_blank" rel="noopener">861. 翻转矩阵后的得分</a></p>
<p>提交记录：<a href="https://leetcode-cn.com/submissions/detail/22283165/" target="_blank" rel="noopener">https://leetcode-cn.com/submissions/detail/22283165/</a></p>
<h3 id="R"><a href="#R" class="headerlink" title="R"></a>R</h3><p>介绍了民主的种类，以及产生过滤泡的一些现象特征，未完</p>
<p><a href="http://note.youdao.com/noteshare?id=31af99bbca34ae471205734c2c99be37&sub=C3A2426B472C43B183CDF16E950D7C40" target="_blank" rel="noopener">Breaking the filter bubble democracy and design</a></p>
<h3 id="T"><a href="#T" class="headerlink" title="T"></a>T</h3><p>关于hexo博客的搭建，现在好像还没有被浏览器收录，这样貌似搜索引擎搜索不到我，暂时就总结一下，并没有尝试过，关于访客记录和文字记录还没有做</p>
<p><a href="http://note.youdao.com/noteshare?id=738f7dfe6cd370f25016914fda6c3e46&sub=56412917BC6C4625A85A91B0266A7E4E" target="_blank" rel="noopener">关于Hexo的浏览器收录</a></p>
<h3 id="S"><a href="#S" class="headerlink" title="S"></a>S</h3><p><a href="https://mp.weixin.qq.com/s/Sv1IldHttIwwT8lIvHVUgQ" target="_blank" rel="noopener">如果可以通过算法来判断女朋友有没有生气</a></p>
<p>有理有据，笑死我了</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Wfc</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">20</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">5</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/wfc1994" title="GitHub &rarr; https://github.com/wfc1994" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:779481237@qq.com" title="E-Mail &rarr; mailto:779481237@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://weibo.com/u/3183050825" title="Weibo &rarr; https://weibo.com/u/3183050825" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="/“”" title="wszgkm &rarr; “”"><i class="fa fa-fw fa-weixin"></i>wszgkm</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-wfc"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wfc</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.1.2</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
    
  
  <script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>













  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.2"></script>

  <script src="/js/motion.js?v=7.1.2"></script>



  
  


  <script src="/js/affix.js?v=7.1.2"></script>

  <script src="/js/schemes/pisces.js?v=7.1.2"></script>




  

  


  <script src="/js/next-boot.js?v=7.1.2"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
